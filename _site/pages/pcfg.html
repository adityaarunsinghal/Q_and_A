<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Coarse-to-fine inference for models with variable structure</title>

    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="/node_modules/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="/node_modules/codemirror/theme/neat.css">
    <link rel="stylesheet" href="/assets/css/custom.css">

    <script src="/bower_components/jquery/dist/jquery.min.js"></script>
    <script src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script src="/node_modules/codemirror/lib/codemirror.js"></script>
    <script src="/node_modules/codemirror/mode/javascript/javascript.js"></script>
    <script src="/assets/js/cm-folding.js"></script>
    <script src="/assets/js/cm-comments.js"></script>
    <script src="/assets/webppl/compiled/webppl.js"></script>
    <script src="/bower_components/paper/dist/paper-full.js"></script>
    <script src="/bower_components/jquery-autosize/jquery.autosize.min.js"></script>
    <script src="/bower_components/d3/d3.min.js"></script>
    <script src="/bower_components/dimple/dist/dimple.v2.1.0.js"></script>
    <script src="/bower_components/underscore/underscore.js"></script>
    <script src="/bower_components/react/JSXTransformer.js"></script>
    <script src="/bower_components/react/react-with-addons.min.js"></script>
    <script src="/bower_components/showdown/compressed/showdown.js"></script>
    <script src="/assets/js/custom.js"></script>    
    <script type="text/jsx" src="/assets/js/editor.js"></script>

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

  </head>
  <body>

    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="/"><strong>Coarse-to-Fine Inference</strong> for <strong>Probabilistic Programs</strong></a>
        </div>
        <ul class="nav navbar-nav navbar-right collapse navbar-collapse">
            <li><a href="/editor.html">Editor</a></li>
        </ul>
      </div>

    </div>

    <div class="container">

      <div class="page-header">
  <h1>Coarse-to-fine inference for models with variable structure</h1>
</div>

<h2 id="introduction">Introduction</h2>

<p>Overall, we need to work out the following issues:</p>

<ul>
  <li>Coarsening multiple variables into a single variable</li>
  <li>Approximation/learning for coarsened primitives</li>
  <li>Automate the transform from a fine-grained model to a coarse-to-fine model</li>
  <li>Coarsening with conditionally existing variables</li>
  <li>Coarsening for nested-query models</li>
  <li>Learn good coarsenings</li>
  <li>Relation to Galois Connections</li>
  <li>Relation to existing coarse-to-fine NLP approaches</li>
  <li>Multi-stage coarsening</li>
</ul>

<p>It’s probably best to pick a specific application that covers multiple issues.</p>

<h2 id="pcfgs">PCFGs</h2>

<p>Let’s think about PCFGs, which I expect will cover the following issues:</p>

<ul>
  <li>Automate the transform from a fine-grained model to a coarse-to-fine model</li>
  <li>Coarsening with conditionally existing variables</li>
  <li>Relation to existing coarse-to-fine NLP approaches</li>
  <li>(Multi-stage coarsening)</li>
</ul>

<p>Let’s first think about a PCFG where coarse-to-fine inference could help. We can construct a PCFG that is similar to the HMM example used in the previous writeup. The rules could look like this:</p>

<pre><code>var rules = {
  'S': {
    rhs: [['X'], ['Y']],
    probs: [.7, 0.3]
  },
  'X': {
    rhs: [['X1'], ['X2'], ['X3']],
    probs: [.33, .33, .33]
  },
  'X1': {
    rhs: [['X1', 'X1'], ['A', 'X1'], ['A']],
    probs: [.33, .33, .33]
  },
  'X2': {
    rhs: [['X2', 'X2'], ['A', 'X2'], ['A']],
    probs: [.33, .33, .33]
  },
  'X3': {
    rhs: [['X3', 'X3'], ['A', 'X3'], ['A']],
    probs: [.33, .33, .33]
  },
  'Y': {
    rhs: [['Y1'], ['Y', 'Y1']],
    probs: [.5, .5]
  },
  'Y1': {
    rhs: [['A'], ['B']],
    probs: [.1, .9]
  }
}
</code></pre>

<p>The most probable sentences under this PCFG look like this:</p>

<pre><code>var transition = function(symbol){
  ///fold: rules
  var rules = {
    'S': {
      rhs: [['X'], ['Y']],
      probs: [.7, 0.3]
    },
    'X': {
      rhs: [['X1'], ['X2'], ['X3']],
      probs: [.33, .33, .33]
    },
    'X1': {
      rhs: [['X1', 'X1'], ['A', 'X1'], ['A']],
      probs: [.33, .33, .33]
    },
    'X2': {
      rhs: [['X2', 'X2'], ['A', 'X2'], ['A']],
      probs: [.33, .33, .33]
    },
    'X3': {
      rhs: [['X3', 'X3'], ['A', 'X3'], ['A']],
      probs: [.33, .33, .33]
    },
    'Y': {
      rhs: [['Y1'], ['Y', 'Y1']],
      probs: [.5, .5]
    },
    'Y1': {
      rhs: [['A'], ['B']],
      probs: [.1, .9]
    }
  };
  ///
  return rules[symbol].rhs[discrete(rules[symbol].probs)];
}

var preTerminal = function(symbol){
  return symbol=='A' | symbol=='B';
}

var terminal = function(symbol){
  // deterministic for now
  return {
    'A' : 'a',
    'B' : 'b'
  }[symbol];
}

var expand = function(symbols, yieldsofar) {
  if (symbols.length==0) {
    return yieldsofar;
  } else {
    return expand(symbols.slice(1), pcfg(symbols[0], yieldsofar));
  }
}

var pcfg = function(symbol, yieldsofar) {
  if (preTerminal(symbol)){
    var t = terminal(symbol);
    return yieldsofar.concat([t]);
  } else {
    return expand(transition(symbol), yieldsofar) }
}

print(Enumerate(function(){return pcfg('S', [])}, 50))
</code></pre>

<p>The principle is the same as for the HMM: There is a class of explanations (namely those involving <code>X</code> nonterminals) that we would like to rule out all at once if we have a sentence that involves a <code>b</code>.</p>

<p>Let’s condition this PCFG and print out the partial program executions as they are enumerated:</p>

<pre><code>///fold:
var printState = function(yieldsofar, symbols, trueyield){
  if (arrayEq(yieldsofar, trueyield) &amp; (symbols.length == 0)){
    print([yieldsofar, symbols, '********************************']);
  } else {
    print([yieldsofar, symbols]);
  } 
}

var arrayEq = function(a, b){
  return a.length == 0 ? (b.length == 0) : a[0]==b[0] &amp; arrayEq(a.slice(1), b.slice(1))
}
///

var transition = function(symbol){
  ///fold: rules
  var rules = {
    'S': {
      rhs: [['X'], ['Y']],
      probs: [.7, 0.3]
    },
    'X': {
      rhs: [['X1'], ['X2'], ['X3']],
      probs: [.33, .33, .33]
    },
    'X1': {
      rhs: [['X1', 'X1'], ['A', 'X1'], ['A']],
      probs: [.33, .33, .33]
    },
    'X2': {
      rhs: [['X2', 'X2'], ['A', 'X2'], ['A']],
      probs: [.33, .33, .33]
    },
    'X3': {
      rhs: [['X3', 'X3'], ['A', 'X3'], ['A']],
      probs: [.33, .33, .33]
    },
    'Y': {
      rhs: [['Y1'], ['Y', 'Y1']],
      probs: [.5, .5]
    },
    'Y1': {
      rhs: [['A'], ['B']],
      probs: [.1, .9]
    }
  };
  ///
  return rules[symbol].rhs[discrete(rules[symbol].probs)];
}

var preTerminal = function(symbol){
  return symbol=='A' | symbol=='B';
}

var terminal = function(symbol){
  // deterministic for now
  return {
    'A' : 'a',
    'B' : 'b'
  }[symbol];
}

var expand = function(symbols, yieldsofar, trueyield) { 
  // printState(yieldsofar, symbols, trueyield);
  if (symbols.length==0) {
    return yieldsofar;
  } else {
    return expand(symbols.slice(1), 
                  pcfg(symbols[0], yieldsofar, trueyield), 
                  trueyield);
  }
}

var pcfg = function(symbol, yieldsofar, trueyield) {
  if (preTerminal(symbol)){
    var t = terminal(symbol);    
    if (yieldsofar.length &lt; trueyield.length){
      factor(t==trueyield[yieldsofar.length] ?0:-Infinity)
    } else {
      null // required because if without else is broken in storepassing
    }
    return yieldsofar.concat([t])
  } else {
    return expand(transition(symbol), yieldsofar, trueyield) }
}

print(
  Enumerate(
    function(){
      var trueyield = ['a', 'a', 'b'];
      var out = pcfg('S', [], trueyield);
      factor(arrayEq(out, trueyield) ? 0 : -Infinity); 
      return out;
    }, 
    32))
</code></pre>

<h2 id="building-a-coarse-to-fine-pcfg">Building a coarse-to-fine PCFG</h2>

<p>How should this work?</p>

<ul>
  <li>The different productions for <code>X</code> are very similar, so we’d like to merge them.</li>
</ul>

<p>How would this work?</p>

<ul>
  <li><code>transition</code> is essentially a dependent ERP, so we would 
    <ol>
      <li>turn it into an independent ERP using factor decomposition, then </li>
      <li>coarsen the resulting independent ERP</li>
    </ol>
  </li>
  <li>This coarsening would merge <code>X1</code>, <code>X2</code>, and <code>X3</code></li>
</ul>

<h3 id="cleaning-up-the-model">Cleaning up the model</h3>

<p>As a first step, I’ll transform the model into a form that is closer to what we worked with last time. That means:</p>

<ul>
  <li>Write transition function as a dependent ERP</li>
  <li>Separate deterministic primitives, erps, and compound model functions</li>
  <li>Write scoring functions for factors as primitives</li>
</ul>

<pre><code>///fold:
var printState = function(yieldsofar, symbols, trueyield){
  if (arrayEq(yieldsofar, trueyield) &amp; (symbols.length == 0)){
    print([yieldsofar, symbols, '********************************']);
  } else {
    print([yieldsofar, symbols]);
  } 
}

var arrayEq = function(a, b){
  return a.length == 0 ? (b.length == 0) : a[0]==b[0] &amp; arrayEq(a.slice(1), b.slice(1))
}

var makeERP = function(ps, vs){
  return Enumerate(function(){return vs[discrete(ps)]});
}
///


// ERPs

var transitionERP = function(symbol){
  ///fold: rules
  var rules = {
    'S': {
      rhs: [['X'], ['Y']],
      probs: [.7, 0.3]
    },
    'X': {
      rhs: [['X1'], ['X2'], ['X3']],
      probs: [.33, .33, .33]
    },
    'X1': {
      rhs: [['X1', 'X1'], ['A', 'X1'], ['A']],
      probs: [.33, .33, .33]
    },
    'X2': {
      rhs: [['X2', 'X2'], ['A', 'X2'], ['A']],
      probs: [.33, .33, .33]
    },
    'X3': {
      rhs: [['X3', 'X3'], ['A', 'X3'], ['A']],
      probs: [.33, .33, .33]
    },
    'Y': {
      rhs: [['Y1'], ['Y', 'Y1']],
      probs: [.5, .5]
    },
    'Y1': {
      rhs: [['A'], ['B']],
      probs: [.1, .9]
    }
  };
  ///
  return makeERP(rules[symbol].probs, rules[symbol].rhs);
}


// Deterministic primitives

var arrayEqualScore = function(out, trueyield){
  return arrayEq(out, trueyield) ? 0 : -Infinity;
}

var equalScore = function(x, y){
  return x==y ? 0 : -Infinity;
}

var preTerminal = function(symbol){
  return symbol=='A' | symbol=='B';
}

var terminal = function(symbol){
  return {
    'A' : 'a',
    'B' : 'b'
  }[symbol];
}


// Compound (model) functions

var expand = function(symbols, yieldsofar, trueyield) { 
  printState(yieldsofar, symbols, trueyield);
  if (symbols.length==0) {
    return yieldsofar;
  } else {
    return expand(symbols.slice(1), 
                  pcfg(symbols[0], yieldsofar, trueyield), 
                  trueyield);
  }
}

var pcfg = function(symbol, yieldsofar, trueyield) {
  if (preTerminal(symbol)){
    var t = terminal(symbol)
    if (yieldsofar.length &lt; trueyield.length){
      factor(equalScore(t, trueyield[yieldsofar.length]));
    } else {
      null
    }
    return yieldsofar.concat([t])
  } else {
    var symbols = sample(transitionERP(symbol));
    return expand(symbols, yieldsofar, trueyield) 
  }
}

var model = function(){
  var trueyield = ['a', 'a', 'b'];
  var out = pcfg('S', [], trueyield);
  factor(arrayEqualScore(out, trueyield)); 
  return out;
}

print(Enumerate(model, 32))
</code></pre>

<p>After some discussion of upcoming issues, we are going to apply the steps outlined in the previous coarse-to-fine document to this model.</p>

<h3 id="problems-ahead">Problems ahead?</h3>

<p>Are there going to be difficulties relating to conditionally existing variables? What about <code>if</code> statements? Can we think in more detail about the stage where all random variables are sampled independently on the abstract level (even if this is only an intermediate stage, and we do later use factors there as well)?</p>

<p>In the first step, we decompose the dependent transition ERP into an independent one (that has full support) and a factor (that adjusts the probabilities, killing of many productions). There are no problems here.</p>

<p>What if we used this model without factors (as we are roughly doing in the second step, when we make a coarse copy)? The model would substantially over-produce, allowing many derivations that are not valid. If we use this model with coarse factors, it might allow some derivations that are not valid (but not necessarily, if the abstractions are well-chosen), but most would be killed off. The ones that remain would be killed of on the fine-grained level.</p>

<p>In summary, there don’t seem to be problems ahead.</p>

<h3 id="matching-up-coarse-grained-and-fine-grained-variables">Matching up coarse-grained and fine-grained variables</h3>

<p>Unlike in the (flattened) HMM discussion, we can no longer use variable names to match up coarse and fine dependent variables and factors. Instead, what I’d like to be able to do, is access the address at any point, and compute relative addresses. Let’s explore this option.</p>

<pre><code>var relativizeAddress = function(address, baseAddress){
  print(baseAddress);
  var commonBase = baseAddress[0];
  return map(function(x){return x-commonBase}, address).slice(1);
}

var foo = function(){
  var baseAddress = getAddress()
  var g = function(){
    var x = getAddress();
    return x
  }
  return relativizeAddress(g(), baseAddress);
}

var bar = function(){
  var baseAddress = getAddress()
  var f = function(){
    var x = getAddress();
    return x;    
  }
  return relativizeAddress(f(), baseAddress);
}

print([foo(), bar()])
</code></pre>

<p>Apparently, the difference in addresses isn’t just a fixed offset. Next step: figure out what exactly it is.</p>

<p>Naming happens before CPS. We can look at the resulting code:</p>

<pre><code>// static

var foo = function (_k104, address) {
    var _return = _k104;
    (function (_s111) {
        getAddress(function (baseAddress) {
            var g = function (_k109, address) {
                var _return = _k109;
                (function (_s110) {
                    getAddress(function (x) {
                        _return(x);
                    }, _s110);
                }(address.concat('_25')));
            };
            (function (_s105) {
                (function (_s106) {
                    (function (_s108) {
                        g(function (_s107) {
                            relativizeAddress(_return, _s106, _s107, baseAddress);
                        }, _s108);
                    }(address.concat('_26')));
                }(address.concat('_27')));
            }(undefined));
        }, _s111);
    }(address.concat('_24')));
};

var bar = function (_k112, address) {
    var _return = _k112;
    (function (_s119) {
        getAddress(function (baseAddress) {
            var f = function (_k117, address) {
                var _return = _k117;
                (function (_s118) {
                    getAddress(function (x) {
                        _return(x);
                    }, _s118);
                }(address.concat('_29')));
            };
            (function (_s113) {
                (function (_s114) {
                    (function (_s116) {
                        f(function (_s115) {
                            relativizeAddress(_return, _s114, _s115, baseAddress);
                        }, _s116);
                    }(address.concat('_30')));
                }(address.concat('_31')));
            }(undefined));
        }, _s119);
    }(address.concat('_28')));
};

(function (_s120) {
    (function (_s125) {
        foo(function (_s122) {
            (function (_s124) {
                bar(function (_s123) {
                    (function (_s121) {
                        print(topK, _s120, _s121);
                    }([
                        _s122,
                        _s123
                    ]));
                }, _s124);
            }(address.concat('_33')));
        }, _s125);
    }(address.concat('_32')));
}(address.concat('_34')));
</code></pre>

<p>The calls to <code>foo</code> and <code>bar</code> receive addresses that differ only by one (33, 34). However, the addresses used within <code>foo</code> and <code>bar</code> differ by <code>4</code>. We need to do two things:</p>

<ol>
  <li>Subtract the address they receive</li>
  <li>Remove the remaining offset</li>
</ol>

<p>Let’s try this:</p>

<pre><code>var relativizeAddress = function(address, baseAddress){
  var relativized = map(function(x){return x-baseAddress[baseAddress.length-1]}, address);
  return relativized.slice(1);
}

var foo = function(){
  var baseAddress = getAddress()
  var g = function(){
    var x = getAddress();
    return x
  }
  var g2 = function(){
    var y = g();
    return y
  }
  return relativizeAddress(g2(), baseAddress);
}

var bar = function(){
  var baseAddress = getAddress()
  var f = function(){
    var x = getAddress();
    return x;    
  }
  var f2 = function(){
    var w = f();
    return w;
  }
  return relativizeAddress(f2(), baseAddress);
}

print([foo(), bar()])
</code></pre>

<p>Ok, looks good.</p>

<p>The remainder of the document will describe the following steps:</p>

<ul>
  <li>Apply factor decomposition to dependent ERPs</li>
  <li>Make a copy of the model that first samples all variables coarsely (without factors), then dependent fine-grained factors. This entails:</li>
  <li>Splitting each random variable into a coarse and (dependent) fine variable</li>
  <li>Accessing the corresponding coarse value (probably using global state - and addresses?)</li>
  <li>Lift functions and add coarse-grained factors</li>
</ul>

<h3 id="decomposing-dependent-erps">Decomposing dependent ERPs</h3>

<p>There is only one ERP in this model: the transition ERP. In the following, we are going to replace it with a uniform transition ERP and a factor that corrects the score.</p>

<pre><code>///fold:
var printState = function(yieldsofar, symbols, trueyield){
  if (arrayEq(yieldsofar, trueyield) &amp; (symbols.length == 0)){
    print([yieldsofar, symbols, '********************************']);
  } else {
    print([yieldsofar, symbols]);
  } 
}

var arrayEq = function(a, b){
  return a.length == 0 ? (b.length == 0) : a[0]==b[0] &amp; arrayEq(a.slice(1), b.slice(1))
}

var makeERP = function(ps, vs){
  return Enumerate(function(){return vs[discrete(ps)]});
}
///


// ERPs

// makeUniformTransitionERP is a function so that everything that
// follows is still on top-level, where mutual recursion
// works (which is necessary for pcfg and expand)  
var makeUniformTransitionERP = function(){
  var symbols = ['S', 'X', 'X1', 'X2', 'X3', 'Y', 'Y1'];  
  return Enumerate(
    function(){
      var symbol = symbols[randomInteger(symbols.length)];
      var erp = transitionERP(symbol);
      return sample(erp);
    });
}

var transitionERP = function(symbol){
///fold: rules
  var rules = {
    'S': {
      rhs: [['X'], ['Y']],
      probs: [.7, 0.3]
    },
    'X': {
      rhs: [['X1'], ['X2'], ['X3']],
      probs: [.33, .33, .33]
    },
    'X1': {
      rhs: [['X1', 'X1'], ['A', 'X1'], ['A']],
      probs: [.33, .33, .33]
    },
    'X2': {
      rhs: [['X2', 'X2'], ['A', 'X2'], ['A']],
      probs: [.33, .33, .33]
    },
    'X3': {
      rhs: [['X3', 'X3'], ['A', 'X3'], ['A']],
      probs: [.33, .33, .33]
    },
    'Y': {
      rhs: [['Y1'], ['Y', 'Y1']],
      probs: [.5, .5]
    },
    'Y1': {
      rhs: [['A'], ['B']],
      probs: [.1, .9]
    }
  };
///
 return makeERP(rules[symbol].probs, rules[symbol].rhs);
}

var transitionScore = function(symbol, rhs){
  var erp = transitionERP(symbol);
  return erp.score([], rhs);
  // TODO: check that this actually works
}


// Deterministic primitives

var arrayEqualScore = function(xs, ys){
  return arrayEq(xs, ys) ? 0 : -Infinity;
}

var equalScore = function(x, y){
  return x==y ? 0 : -Infinity;
}

var preTerminal = function(symbol){
  return symbol=='A' | symbol=='B';
}

var terminal = function(symbol){
  return {
    'A' : 'a',
    'B' : 'b'
  }[symbol];
}


// Compound (model) functions
  
var expand = function(symbols, yieldsofar, trueyield, env) { 
  // printState(yieldsofar, symbols, trueyield);
  if (symbols.length==0) {
    return yieldsofar;
  } else {
    return expand(symbols.slice(1), 
                  pcfg(symbols[0], yieldsofar, trueyield, env), 
                  trueyield, 
                  env);
  }
}

var pcfg = function(symbol, yieldsofar, trueyield, env) {
  if (preTerminal(symbol)){
    var t = terminal(symbol)
    if (yieldsofar.length &lt; trueyield.length){
      factor(equalScore(t, trueyield[yieldsofar.length]));
    } else { null }
    return yieldsofar.concat([t])
  } else {
    var symbols = sample(env.uniformTransitionERP);
    var uScore = env.uniformTransitionERP.score([], symbols);
    var tScore = transitionScore(symbol, symbols);
    factor(tScore - uScore);
    return expand(symbols, yieldsofar, trueyield, env);
  };
}

var model = function(){
  var env = {
    uniformTransitionERP : makeUniformTransitionERP()
  };
  var trueyield = ['a', 'a', 'b'];
  var out = pcfg('S', [], trueyield, env);
  factor(arrayEqualScore(out, trueyield)); 
  return out;
}

print(Enumerate(model, 70))
</code></pre>

<p>The distribution is the same, but we had to enumerate a lot longer due to splitting up the dependent ERP into an independent ERP (with broad support) and a factor (that narrows the support).</p>

<h3 id="splitting-the-model-into-coarse-and-fine">Splitting the model into coarse and fine</h3>

<p>This covers two steps in the old writeup:</p>

<ul>
  <li>Decomposing random variables</li>
  <li>Lifting deterministic functions and factors</li>
</ul>

<p>The reason for merging these two steps is that, for structurally more complex models, we can’t just split the variables directly, as they get created at runtime. This means that we need to split the entire model, which requires that we deal with deterministic functions and factors.</p>

<p>Before we do this for the PCFG, let’s split a simpler model using addresses.</p>

<h3 id="interlude-splitting-a-simpler-model">Interlude: Splitting a simpler model</h3>

<p>Let’s think about coarsening the following simple model that has just a single random variable:</p>

<pre><code>///fold:
var makeERP = function(ps, vs){
  return Enumerate(function(){return vs[discrete(ps)]});
}
///

var erp = makeERP([.1,.3,.6], ["a", "b", "c"]);

var model = function(){
  var f = function(){
    return sample(erp);
  }
  return f();
}

print(Enumerate(model))
</code></pre>

<p>There are no dependent erps, so we don’t need to decompose them. There are also no primitive functions or factors, so all we need to do is split the erp into coarse and fine, now using addressing to identify coarse and fine erp.</p>

<pre><code>///fold:
var makeERP = function(ps, vs){
  return Enumerate(function(){return vs[discrete(ps)]});
}
///

var erp = makeERP([.1,.3,.6], ["a", "b", "c"]);

var model = function(){
  var f = function(){
    return sample(erp);
  }
  return f();
}

print(Enumerate(model))
</code></pre>

<p>We are going to store erp information in the global store based on addresses as follows:</p>

<pre><code>var name = "erp_" + getAddress().join();
globalStore[name] = "this is a test";
print(name);
print(globalStore[name]);
</code></pre>

<p>The new coarse-to-fine model is going to look like this:</p>

<pre><code>///fold:
var makeERP = function(ps, vs){
  return Enumerate(function(){return vs[discrete(ps)]});
}

var getRelativeAddress = function(baseAddress){
  var address = getAddress();
  var relativized = map(function(x){return x-baseAddress[baseAddress.length-1]}, address);
  return relativized.slice(2, -1); // &lt;- FIXME
}

var coarsenERP = function(erp, coarsenValue){

  // Get concrete values and probabilities
  
  var allVs = erp.support([]);
  var allPs = map(function(v){return Math.exp(erp.score([], v));}, allVs);

  // Group distribution based on equivalence classes
  // implied by coarsenValue function

  var groups = groupBy(
    function(vp1, vp2){
      return coarsenValue(vp1[0]) == coarsenValue(vp2[0]);
    },
    zip(allVs, allPs));
  
  var groupSymbols = map(
    function(group){
      // group[0][0]: first value in group
      return coarsenValue(group[0][0])},
    groups)

  var groupedVs = map(
    function(group){
      return map(first, group);
    },
    groups);

  var groupedPs = map(
    function(group){
      return map(second, group);
    },
    groups);

  // Construct unconditional (abstract) sampler and
  // conditional (concrete) sampler

  var abstractPs = map(sum, groupedPs);
  var abstractSampler = makeERP(abstractPs, groupSymbols);
  var getAbstractSampler = function(relAddress){
    return function(){
      var x = sample(abstractSampler);
      var name = "erp_" + relAddress.join();
      globalStore[name] = x;
      return x;
    }
  }
  
  var groupERPs = map2(makeERP, groupedPs, groupedVs);    
  var getConcreteSampler = function(relAddress){
    var name = "erp_" + relAddress.join();    
    console.log(globalStore);
    console.log(name);
    var abstractSymbol = globalStore[name];
    console.log("looked up abstract symbol: " + abstractSymbol);
    return function(){
      var i = indexOf(abstractSymbol, groupSymbols);
      var fineErp = groupERPs[i];
      var x = sample(fineErp);
      return x;
    }
  }
  
  return [getAbstractSampler, getConcreteSampler];

}
///

var testERP = makeERP([.1,.3,.6], ["a", "b", "c"]);

var abstractionMap = {
  "a": "x",
  "b": "x",
  "c": "y",
}

var coarsenValue = function(value){
  if (abstractionMap.hasOwnProperty(value)){
    return abstractionMap[value];
  } else {
    return value; // value is unchanged in abstract domain
  }
}


// Decomposed random variable

var tmp = coarsenERP(testERP, coarsenValue);
var getCoarseTestERP = tmp[0];
var getFineTestERP = tmp[1];

var coarseModel = function(){
  var baseAddress = getAddress();
  var f = function(){
    return getCoarseTestERP(getRelativeAddress(baseAddress))();
  }
  return f();
}

var fineModel = function(){
  var baseAddress = getAddress();
  var f = function(){
    return getFineTestERP(getRelativeAddress(baseAddress))();
  }
  return f();    
}

var model = function(){
  coarseModel();
  return fineModel();
}

print(Enumerate(model))
</code></pre>

<p>This worked, but we had to mangle the relative address.</p>

<p>Next steps:</p>

<ul>
  <li>Make relative addresses more reliable (understand how to select the correct subset)</li>
  <li>Simplify code</li>
  <li>Apply to PCFG</li>
  <li>Automation</li>
</ul>


<div class="editThisPage">
  <a id="github-edit-link" href="#" class="btn btn-default">Edit this page</a>
</div>

<script type="text/javascript">
  $("#github-edit-link").attr("href", github_edit_url("/pages/pcfg.html"));
</script>


    </div><!-- /.container -->

  </body>
</html>
