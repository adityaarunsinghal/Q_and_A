// --------------------------------------------------------------------
// Original preamble

var makeERP = function(ps, vs){
  return Enumerate(function(){return vs[discrete(ps)]});
};


// ---------------------------------------------------------------------
// CtF preamble

var butLast = function(xs){
  return xs.slice(0, xs.length-1);
}

var flatten = function(xs){
  if (xs.length == 0) {
    return [];
  } else {
    return xs[0].concat(flatten(xs.slice(1)));
  }
}

var productOfLists = function(xs){
  if (xs.length == 0) {
    return [[]];
  } else {
    var xrs = productOfLists(xs.slice(1));
    return flatten(map(
      function(x0){
        map(function(l){return [x0].concat(l);}, xrs);
      },
      xs[0]));
  }
}

var arrayEq = function(a, b){
  return (a.length == 0 ?
          (b.length == 0) :
          a[0]==b[0] & arrayEq(a.slice(1), b.slice(1)));
};

var removeCommonPrefix = function(xs, ys){
  if ((xs.length == 0) | (ys.length == 0)) {
    return [xs, ys];
  } else if (xs[0] === ys[0]){
    return removeCommonPrefix(xs.slice(1), ys.slice(1));
  } else {
    return [xs, ys];
  }
};

var getRelativeAddress = function(baseAddress){
  // 1. Get address
  var a = getAddress();
  // 2. Remove last element (since last element
  // just points to the getAddress call here, not the
  // surrounding context that we care about)
  var addr = a.slice(0, a.length - 1);
  // 3. Remove common prefix with base address (since prefix
  // reflects context that we want to ignore)
  var tmp = removeCommonPrefix(baseAddress, addr);
  if (tmp[0].length != 1){
    console.error("getRelativeAddress failed");
    console.log(baseAddress);
    console.log(addr);
    return undefined;
  } else {
    var base0 = tmp[0][0];
    // 4. Subtract last element of base address (to normalize
    // absolute value of addresses that happen in different
    // syntactic places)
    var relativized = map(
      function(x){return x-base0;},
      tmp[1]);
    return relativized;
  }
};

var initialGroup = function(vs, ps, coarsenValue){
  
  // Group distribution based on equivalence classes
  // implied by coarsenValue function

  var groups = groupBy(
    function(vp1, vp2){
      return JSON.stringify(coarsenValue(vp1[0])) == JSON.stringify(coarsenValue(vp2[0]));
    },
    zip(vs, ps));

  var groupedVs = map(
    function(group){
      return map(first, group);
    },
    groups);

  var groupedPs = map(
    function(group){
      return map(second, group);
    },
    groups);    
  
  var groupSymbols = map(
    function(group){
      // group[0]: first value in group
      return JSON.stringify(coarsenValue(group[0]));},
    groupedVs);

  var obj = {    
    level: 1,
    vs: groupedVs,
    ps: groupedPs,
    syms: groupSymbols      
  }  
  
  return obj;
}


var recursivelyGroup = function(objs, coarsenValue, n){

  if (objs[0].level == n){
    
    return objs;
    
  } else {
        
    var newVs = map(
      function(vs){return coarsenValue(vs[0]);}, 
      objs[0].vs);
    
    var newPs = map(sum, objs[0].ps);
    
    var groups = groupBy(
      function(vp1, vp2){
        return JSON.stringify(coarsenValue(vp1[0])) == JSON.stringify(coarsenValue(vp2[0]));
      },
      zip(newVs, newPs)
    );
        
    var groupedVs = map(
      function(group){
        return map(first, group);
      },
      groups);

    var groupedPs = map(
      function(group){
        return map(second, group);
      },
      groups);    
    
    var groupSymbols = map(
      function(group){
        // group[0]: first value in group
        return JSON.stringify(coarsenValue(group[0]));},
      groupedVs);    
    
    var nextObj = {    
      level: objs[0].level + 1,
      vs: groupedVs,
      ps: groupedPs,
      syms: groupSymbols      
    }
    
    return recursivelyGroup([nextObj].concat(objs), coarsenValue, n);
  }
  
};


var coarsenERP = function(erp, coarsenValue, levels){

  // Get concrete values and probabilities
  var allVs = erp.support([]);
  var allPs = map(function(v){return Math.exp(erp.score([], v));}, allVs);
  
  var groups = recursivelyGroup(
    [initialGroup(allVs, allPs, coarsenValue)],
    coarsenValue,    
    levels);
  
  return map(
    function(group){
                             
      var groupERPs = map2(makeERP, group.ps, group.vs);
      
      var getTopErp = function(group, name){
        var index = discrete(map(sum, group.ps));
        return groupERPs[index];
      };
      
      var getInternalErp = function(group, name){
        // console.log(globalStore);
        // console.log(name + "_" + (group.level + 1));
        var coarseSymbol = JSON.stringify(globalStore[name + "_" + (group.level + 1)]);        
        var i = indexOf(coarseSymbol, group.syms);
        return groupERPs[i];
      };
      
      return function(){
        var relAddress = butLast(getRelativeAddress(globalStore.baseAddress));
        var name = "erp_" + relAddress.join();          
        var fineErp = (group.level == levels) ? getTopErp(group, name) : getInternalErp(group, name);
        var x = sample(fineErp);
        globalStore[name + "_" + group.level] = x;
        // console.log('Setting', name + "_" + group.level, 'to', x);
        return x;
      }      
      
    }, 
    groups
  );

};

var logMeanExp = function(erp){
  return Math.log(expectation(erp, function(x){return Math.exp(x);}));
};

var lift1 = function(f, coarsenValue, refineValue, useMean){

  var getOutputSampler = cache(function(coarseArg){
    var fineArgs = refineValue(coarseArg);
    return Enumerate(
      function(){
        var fineArg = fineArgs[randomInteger(fineArgs.length)];
        var fineOut = f(fineArg);
        var coarseOut = coarsenValue(fineOut);
        return coarseOut;
      });
  });

  var samplerToValue = useMean ? logMeanExp : sample;

  return function(coarseArg){
    var outputSampler = getOutputSampler(coarseArg);
    return samplerToValue(outputSampler);
  };

};

var lift2 = function(f, coarsenValue, refineValue, useMean){

  var getOutputSampler = cache(function(coarseArg1, coarseArg2){
    var fineArgs1 = refineValue(coarseArg1);
    var fineArgs2 = refineValue(coarseArg2);
    return Enumerate(
      function(){
        var fineArg1 = fineArgs1[randomInteger(fineArgs1.length)];
        var fineArg2 = fineArgs2[randomInteger(fineArgs2.length)];
        var fineOut = f(fineArg1, fineArg2);
        var coarseOut = coarsenValue(fineOut);
        return coarseOut;
      });
  });

  var samplerToValue = useMean ? logMeanExp : sample;

  return function(coarseArg1, coarseArg2){
    var outputSampler = getOutputSampler(coarseArg1, coarseArg2);
    return samplerToValue(outputSampler);
  };

};

var c2Factor = function(score){
  var relativeAddress = butLast(getRelativeAddress(globalStore.baseAddress));
  var name = "factor_" + relativeAddress.join() + '_c2';
  var proxyScore = (score == -Infinity) ? Math.log(0.0001) : score;
  globalStore[name] = proxyScore;
  factor(proxyScore);
};

var coarseFactor = function(score){
  var relativeAddress = butLast(getRelativeAddress(globalStore.baseAddress));
  var coarseName = "factor_" + relativeAddress.join() + '_c2';
  var coarseScore = globalStore[coarseName];
  var name = "factor_" + relativeAddress.join();
  var proxyScore = (score == -Infinity) ? Math.log(0.0001) : score;
  globalStore[name] = proxyScore;
  factor(proxyScore - coarseScore);
};

var fineFactor = function(score, relativeAddress){
  var relativeAddress = butLast(getRelativeAddress(globalStore.baseAddress));
  var name = "factor_" + relativeAddress.join();
  var coarseScore = globalStore[name];
  // console.log("fine factor: ", score, " - ", coarseScore);
  if ((coarseScore == -Infinity) & (score == -Infinity)){
    factor(-Infinity);
  } else if (coarseScore == -Infinity) {
    console.error('ERROR: coarse is -Inf, but fine is not!');
    process.exit();
  } else {
    factor(score - coarseScore);
  }
};


// --------------------------------------------------------------------
// Original defs

var xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

var erpX = makeERP([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1], xs);

var makeErpY = function(x){
  var ps = ((x < 8) ? 
            [.05, .05, .05, .05, .05, .05, .2, .2, .2, .1] :
            [.05, .05, .2, .2, .2, .1, .05, .05, .05, .05]);
  return makeERP(ps, xs);
}

var plus = function(x, y){ return x + y; };
var times = function(x, y){ return x * y; };

var scoreZ = function(z){
  return z > 30 ? 0 : -Infinity;
};


// --------------------------------------------------------------------
// Independent erp defs

// - for dependent erps, need to know input domain
//   (and ideally marginal distribution of input)

var makeUniformERP = function(xs){
  return Enumerate(function(){
    return xs[randomInteger(xs.length)];
  });
};

var uniformErpY = makeUniformERP(xs);

var erpYScore = function(x, y){
  return makeErpY(x).score([], y);
}

var uniformErpYScore = function(y){
  return uniformErpY.score([], y);
}


// --------------------------------------------------------------------
// Coarsening and refinement functions

var isUpper = function(x0, x1){
  var size = x1 - x0 + 1;
  return x1 % (size * 2) == 0;
};

var coarsenValue = function(x){
  // console.log('coarsen:', x);
  if (x instanceof Array){
    // interval
    var x0 = x[0];
    var x1 = x[1];
    var size = x1 - x0 + 1;
    if (isUpper(x0, x1)){
      return [(x0 - size), x1];
    } else {
      return [x0, x1 + size];
    }
  } else {
    // number
    if (x <= 0) {
      // score
      return x;
    } else {
      if (x % 2 == 0) {
        return [x-1, x];
      } else {
        return [x, x+1];
      }
    }
  }
};

var refineValue = function(x){
  // console.log('refine:', x);
  if (x instanceof Array){
    // interval
    var x0 = x[0];
    var x1 = x[1];
    var size = (x1 - x0 + 1) / 2;
    if (size == 1){
      return [x0, x1];
    } else {
      return [[x0, x1-size], [x0 + size, x1]];
    }
  } else {
    if (x <=0){
      // score
      return [x];
    } else {
      console.error('tried to refine plain number!');
      return "ERROR";
    }
  }
};


// --------------------------------------------------------------------
// CtF defs

var tmp1 = coarsenERP(erpX, coarsenValue, 3);
var sampleC2X = tmp1[0]
var sampleCoarseX = tmp1[1];
var sampleFineX = tmp1[2];

var tmp2 = coarsenERP(uniformErpY, coarsenValue, 3);
var sampleC2UniformY = tmp2[0];
var sampleCoarseUniformY = tmp2[1];
var sampleFineUniformY = tmp2[2];

var coarsePlus = lift2(plus, coarsenValue, refineValue, false);
var coarseTimes = lift2(times, coarsenValue, refineValue, false);
var coarseScoreZ = lift1(scoreZ, coarsenValue, refineValue, true);
var coarseErpYScore = lift2(erpYScore, coarsenValue, refineValue, true);
var coarseUniformErpYScore = lift1(uniformErpYScore, coarsenValue, refineValue, true);

var c2Plus = lift2(coarsePlus, coarsenValue, refineValue, false);
var c2Times = lift2(coarseTimes, coarsenValue, refineValue, false);
var c2ScoreZ = lift1(coarseScoreZ, coarsenValue, refineValue, true);
var c2ErpYScore = lift2(coarseErpYScore, coarsenValue, refineValue, true);
var c2UniformErpYScore = lift1(coarseUniformErpYScore, coarsenValue, refineValue, true);


// --------------------------------------------------------------------
// CtF model

var c2Foo = function(x, y){
  return c2Times(c2Plus(x, y), coarsenValue(coarsenValue(2)));
};

var c2Model = function(){
  globalStore['baseAddress'] = getAddress();
  var x = sampleC2X();
  var y = sampleC2UniformY();
  c2Factor(c2ErpYScore(x, y) - c2UniformErpYScore(y));
  var z = c2Foo(x, y);
  c2Factor(c2ScoreZ(z));
  return x;
};

var coarseFoo = function(x, y){
  return coarseTimes(coarsePlus(x, y), coarsenValue(2));
};

var coarseModel = function(){
  globalStore['baseAddress'] = getAddress();
  var x = sampleCoarseX();
  var y = sampleCoarseUniformY();
  coarseFactor(coarseErpYScore(x, y) - coarseUniformErpYScore(y));
  var z = coarseFoo(x, y);
  coarseFactor(coarseScoreZ(z));
  return x;
};


var foo = function(x, y){
  return times(plus(x, y), 2);
};

var fineModel = function(){
  globalStore['baseAddress'] = getAddress();
  var x = sampleFineX();
  var y = sampleFineUniformY();
  fineFactor(erpYScore(x, y) - uniformErpYScore(y));
  var z = foo(x, y);
  fineFactor(scoreZ(z));
  return x;
};


var coarseToFineModel = function(){
  c2Model();
  coarseModel();
  return fineModel();
}

Enumerate(coarseToFineModel);
