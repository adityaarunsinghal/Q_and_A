---
title: "Questions and Answers in Dialogue"
output: html_notebook
---

# Imports 

```{r}
library(tidyverse)

library(GGally)
library(coda)
library(boot)

estimate_mode <- function(s) {
  d <- density(s)
  return(d$x[which.max(d$y)])
}

HPDhi<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","upper"])
}

HPDlo<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","lower"])
}
options("scipen"=10) 
# opts_knit$set(root.dir = '')
# setwd("/Users/rxdh/Box Sync/stanford/research/goodman/q&a/MultiExperiment2/")

```

Experiment data analysis
--------------------------

Start by setting up exclusion criteria for participants who don't speak english or didn't complete the full task.

```{r}
subjInfo = read_csv("../data/compiled-subject_information.csv")

mturk = read_csv("../data/compiled-mturk.csv") %>%
  mutate(gameid = Answer.id) %>%
  select(workerid, gameid)

rawAggregated = read_csv("../data/compiled-trials_clean.csv") %>%
  right_join(mturk, by = 'workerid') %>%
  right_join(subjInfo, by = 'workerid')
```

Filter out participants who didn't complete all 12 trials, had missing data (i.e. didn't answer for some subset of trials), or didn't list english as their native language, then keep one of each game

```{r}
nonNativeSpeaker <- rawAggregated %>% 
  filter(nativeEnglish != "yes")

incomplete = rawAggregated %>% 
  group_by(gameid) %>% 
  count(gameid) %>% 
  mutate(numCompleted = n) %>% 
  filter(numCompleted != 24)

missingData = rawAggregated %>%
  filter(is.na(answer))

badGames <- union(
  nonNativeSpeaker$gameid, 
  union(incomplete$gameid, missingData$gameid)
)

d <- rawAggregated %>%
  filter(!(gameid %in% badGames)) %>%
  distinct(domain, goal, question, guess, answer, type, gameid)
  
write_csv(d, "../data/BayesianAnalysisInput.csv")
```

In order to compare different items in a convenient way, we're going to map the questions and answers to the corresponding node positions in the hierarchy. So, in 'branching' trials, for example, 'dalmatian', 'mansion', 'carrot', and 'couch' would all be treated the same.


```{r}
source("./analysisHelpers.R")
d <- mapWordsToNodes(d)
```

We're also going to estimate empirical probabilities for each response, conditioned on the domain, type, and goal of the trial. To get confidence intervals for these estimates, we'll use the bootstrap. Tidy up questioner data...

```{r}
d_q = d %>% 
      mutate(response=ordered(questionNodes, levels=c("Q1","Q2","Q3","Q4"))) %>%
      mutate(goal = ordered(goalNodes, levels = c("G1", "G2", "G3", "G4"))) %>%
      group_by(domain, type, goal) %>%
      do(getProbsAndCIs(data = ., QorA = 'q', R = 1000, FALSE)) %>%
      select(goal, type, response, domain, count, lower_ci, upper_ci,
             groupSize, empProb) %>%
      ungroup() %>%
      # Note that there are no Q3 & Q4 in the equivocal condition
      filter(!(type == "equivocal" & (response == "Q3" | response == "Q4"))) %>%
      mutate(domain = factor(domain),
             type = factor(type),
             goal = ordered(goal, levels=c("G1","G2","G3","G4")))
```

Tidy up answerer data...

```{r}
d_a = d %>% 
      mutate(response=ordered(answerNodes,levels=c("A1","A2","A3","A4"))) %>%
      mutate(utterance=ordered(questionNodes,levels=c("Q1","Q2","Q3","Q4"))) %>%
      group_by(domain, type, utterance) %>%
      do(getProbsAndCIs(data = ., QorA = 'a', R = 1000, FALSE)) %>%
      select(utterance, type, response, domain, count,lower_ci, upper_ci,
             groupSize, empProb) %>%
      ungroup() %>%
      mutate(domain = factor(domain),
             type = factor(type),
             utterance = ordered(utterance, levels=c("Q1","Q2","Q3","Q4")))
```

# Qualitative Behavioral Results

### Correlations between domains

```{r}
col1 = subset(d_q, domain == "animals")$empProb
col2 = subset(d_q, domain == "places")$empProb
col3 = subset(d_q, domain == "plants")$empProb
col4 = subset(d_q, domain == "artifact")$empProb
corData_q = data.frame(animal = col1, place = col2, plant = col3, artifact = col4)
cat('questioner domain correlations:\n')
cor(corData_q)

col1 = subset(d_a, domain == "animals")$empProb
col2 = subset(d_a, domain == "places")$empProb
col3 = subset(d_a, domain == "plants")$empProb
col4 = subset(d_a, domain == "artifact")$empProb
corData_a = data.frame(animal = col1, place = col2, plant = col3, artifact = col4)
cat('\nanswerer domain correlations:\n')
cor(corData_a)
```

### Answerer deviation from uniform

for example:

```{r}
# Collapse across domains
overall_distribution = (d_a %>% 
                          group_by(utterance, type, response) %>% 
                          summarize(count = sum(count)))
print(overall_distribution %>% 
        filter(utterance == 'Q4' & type == 'branching') %>%
        mutate(prob = count / sum(count)))
```

statistical test:

```{r}
chisq.test(subset(overall_distribution, 
                  utterance == "Q4"& type == "branching")$count)
```

### Questioner overlapping condition

Make plot

```{r}
gs = c("G1", "G2", "G3", "G4")
qs = c("Q1","Q2","Q3","Q4")
collapsed_q <- d %>% 
    mutate(response = ordered(questionNodes, levels = qs)) %>%
    mutate(goal = ordered(goalNodes, levels = gs)) %>%
    group_by(goal,type) %>%
    filter(type == "overlapping") %>%
    do(getProbsAndCIs(data = ., QorA = 'q', R = 1000, TRUE)) %>%
    mutate(empirical = empProb) %>%
    select(goal, type, response, count, lower_ci, upper_ci, 
           groupSize, empirical)

plottableQ = collapsed_q %>% 
  filter(goal == "G2") %>%
  mutate(response = factor(response, levels = qs, 
                           labels = c('lion?', 'cat?', 'pet?', 'animal?')))

(ggplot(plottableQ, aes(x = response, y = empirical))
 + geom_bar(position = 'dodge', stat= 'identity')
 + geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), 
                 position = 'dodge', width =.25)
 + ggtitle("Question asked in overlapping condition\nwhen goal is to find 'house cat'")
 + theme_few(9)
 + ylim(0,1)
 + ylab('% participants'))

ggsave("../writing/2016/journal-manuscript/figures/OverlappingModelComparison.pdf", 
       width = 3.5, height=2)
```

get statistical result

```{r}
cat('Q2:', round(subset(plottableQ, response == 'cat?')$empirical, 2))
cat('\nQ3:', round(subset(plottableQ, response == 'pet?')$empirical, 2))

diffScore <- function(data, indices) {
  d <- data[indices,] %>%
    group_by(response) %>%
    summarize(count = n()) %>%
    ungroup() %>%
    mutate(prob = count / sum(count)) %>%
    select(-count) %>%
    spread(response, prob)
  return(d$Q2 - d$Q3)
}

bootRes = d %>% 
  mutate(response = ordered(questionNodes, levels = c("Q1","Q2","Q3","Q4"))) %>%
  mutate(goal = ordered(goalNodes, levels = c("G1", "G2", "G3", "G4"))) %>%
  group_by(goal,type) %>%
  filter(type == "overlapping") %>%
  filter(goal == "G2") %>%
  boot(statistic = diffScore,R=1000) 

estimate <- round(bootRes$t0,2)
lowerDiffScore <- round(boot.ci(bootRes, type = "perc")$percent[4],2)
upperDiffScore <- round(boot.ci(bootRes, type = "perc")$percent[5],2)
cat(paste0(c('\nQ3-Q2 = ', estimate,
             '[', lowerDiffScore, 
             ', ', upperDiffScore, ']')))
```

# Bayesian Data Analysis

Define some helper functions...

```{r}
# renormalize posterior for fixed beta/modelType
# (returns full joint posterior if none specified)
getRawParams = function(name, chosenBeta=NA, chosenModelType=NA) {
  inputName <- paste0("../modeling/guessingGame/Bayesian/data/", name, '.csv')
  
  raw <- read_csv(inputName) %>%
    mutate(t = floor((row_number()-1)/3)) %>%
    spread(parameter, value) %>%
    filter(MCMCprob != '-Inf')
  
  if(!is.na(chosenBeta)) {
    raw <- raw %>%
      mutate(beta = as.character(beta)) %>%
      filter(beta == chosenBeta) %>%
      mutate(intermed = exp(MCMCprob - max(MCMCprob))) %>%
      mutate(MCMCprob = log(intermed/sum(intermed))) %>%
      select(-intermed, -beta) 
  } 
  if(!is.na(chosenModelType)){
    raw <- raw %>%
      filter(modelType == chosenModelType) %>%
      mutate(intermed = exp(MCMCprob - max(MCMCprob))) %>%
      mutate(MCMCprob = log(intermed/sum(intermed))) %>%
      select(-intermed, -modelType) 
  } 
  return(raw)
}

sumlogprob <- function(a, b) {
  if(a>b) {
    return(a+log1p(exp(b-a)))
  } else{
    return(b+log1p(exp(a-b)))
  }
}

printTable <- function(samples) {
  cat('parameter posteriors')
  print(samples %>%
    group_by(parameter) %>%
    summarize(md_lo = round(HPDlo(value), 3),
              md_hi = round(HPDhi(value), 3),
              value = estimate_mode(value)))
}
```

## Without empirical typicalities

### Model Comparison 

```{r}
modelComparison <- function(name, useTypicality) {
  beta <- ifelse(useTypicality, NA, 0)
  data <- getRawParams(name, chosenBeta = beta)

  return(data %>% 
    group_by(modelType) %>% 
    summarize(prob = reduce(MCMCprob, sumlogprob))
  )
}

# Marginalize over alpha
cat('BF (beta=0, answerer)')
modelComparison("answerer_modelComparisonParams", FALSE)
cat('BF (beta=0, questioner)')
modelComparison("questioner_modelComparisonParams", FALSE)
```

### Examine posteriors

Set up helper functions. Note that we only look at the parameter posterior for the model that won our model comparison (otherwise this would be a mixture of the best parameters for each model we considered)

```{r}
examineParams <- function(name, useTypicality, winningModel) {
  beta <- ifelse(useTypicality, NA, 0)

  samples = getRawParams(name, chosenBeta = beta, chosenModelType = winningModel) %>% 
    mutate(MCMCprob = exp(MCMCprob)) %>%
    filter(MCMCprob > 0.001) %>%
    mutate(n = floor(MCMCprob*1000)) %>%
    do(data.frame(.[rep(1:nrow(.), .$n),])) %>%
    select(-t, -n, -MCMCprob) %>%
    gather(parameter, value) %>%
    mutate(value = as.numeric(as.character( value)))

  printTable(samples)
  
  questionParamPosterior <- ggplot(samples, aes(x = value))+
      geom_histogram(aes(y=..density..), 
                   data =subset(samples, parameter == "alpha" ), 
                   binwidth = .25, colour="black", fill="white") +
      geom_histogram(aes(y=..density..), 
                   data=subset(samples, parameter == "beta"), 
                   binwidth = .05, colour="black", fill="white") +
      geom_density(aes(y=..density..),
                   data =subset(samples, parameter == "alpha" ), 
                   adjust = 2, alpha=.2, fill="#FF6666")+
      geom_density(aes(y=..density..),
                   data=subset(samples, parameter == "beta"), 
                   adjust = 5, alpha=.2, fill="#FF6666")+
      facet_wrap(~parameter, scales = 'free') +
      theme_few(9)
  
  print(questionParamPosterior)
  outputName = paste0("../writing/2016/journal-manuscript/figures/",
                     name, ".pdf")
  ggsave(outputName, questionParamPosterior, 
         width = 6, height = 3, bg = "transparent")
}
```

Answerer (no typicality)

```{r}
examineParams('answerer_modelComparisonParams', useTypicality=FALSE)
```

Questioner (no typicality)

```{r}
examineParams('questioner_modelComparisonParams', useTypicality=FALSE)
```

## Examine posterior predictives

```{r}
getRawPredictives <- function(name, chosenBeta = NA, chosenModelType = NA) {
  read.csv(inputname, sep = ",", row.names = NULL)   
}

```

```{r}
examinePredictives <- function(name, useTypicality, winningModel) {
  inputname <- paste0('../../guessingGame/Bayesian/data/', name, '.csv')
  
  
  beta <- ifelse(useTypicality, NA, 0)

  samples = getRawParams(name, chosenBeta = beta, chosenModelType = winningModel) %>% 
    mutate(MCMCprob = exp(MCMCprob)) %>%
    filter(MCMCprob > 0.001) %>%
    mutate(n = floor(MCMCprob*1000)) %>%
    do(data.frame(.[rep(1:nrow(.), .$n),])) %>%
    select(-t, -n, -MCMCprob) %>%
    gather(parameter, value) %>%
    mutate(value = as.numeric(as.character( value)))

  if(typicality == 'withoutTypicality') {
    apredictive.samples <- apredictive %>% 
      filter(beta == 0) %>%
      filter(MCMCprob == max(MCMCprob))
  } else {
    apredictive.samples <- filter(MCMCprob > 0.0001) %>% 
      apredictive[rep(row.names(apredictive),
                  apredictive$MCMCprob*1000), 
                  -length(colnames(apredictive))]
  }

  apredictive.samples <- apredictive.samples %>%
    mutate(question = as.character(parameter),
           answer = substr(as.character(value), 1, 
                           nchar(as.character(value)) - 1),
           type = as.character(item1),
           domain = as.character(item2)) %>%
    do(mutate(., answer = vectorizedMapAnswer(type, answer))) %>%
    do(mutate(., question = vectorizedMapQuestion(type, question))) %>%
    mutate(utterance = as.factor(question), response = as.factor(answer)) %>%
    select(type, domain, utterance, response, prob)
  View(apredictive.samples)
  apredictive.pp <- apredictive.samples %>%
    group_by(type, domain, utterance, response) %>%
    summarize(MAP = prob) %>%
              # credHigh = HPDhi(prob),
              #credLow = HPDlo(prob)) %>%
    right_join(d_a, by = c("response", "utterance", "domain", "type"))
  #View(apredictive.pp)
  acor = round(cor(apredictive.pp$MAP, apredictive.pp$empProb), 2)

  answer_plots = (ggplot(apredictive.pp, aes(x = MAP, y = empProb))
    + theme(text = element_text(size = 20),
            axis.text.x = element_text(angle=90, vjust=1))
    + xlab("Model predicted probability")
    + ylim(0,1)
    + ylab("Empirical Probability")
    #+ geom_errorbar(aes(ymax = upper_ci, ymin = lower_ci)) 
    #+ geom_errorbarh(aes(xmax = credHigh, xmin = credLow))
    + geom_point(aes(colour = domain, shape = type))
    + geom_abline(intercept = 0, slope = 1, linetype = "dotted")
    + scale_x_continuous(lim = c(0,1), breaks=c(0,.5,1))
    + ggtitle("Answerer Posterior Predictive")
    + geom_smooth(method = "lm")
    + annotate('text', label = paste0('r =',acor), x= 0.8, y = 0.1, size = 8)
    + coord_fixed() 
    + theme(rect = element_rect(fill = "transparent"), # bg of the panel
            panel.background = element_rect(fill = "transparent",colour = NA),
            plot.background = element_rect(fill = "transparent",colour = NA),
            panel.grid.major = element_blank(), # get rid of major grid
            panel.grid.minor = element_blank(), # get rid of minor grid
            legend.background = element_rect(fill = "transparent",colour = NA),
            legend.box.background = element_rect(fill = "transparent",colour = NA) # get rid of legend panel bg
  ))
  print(answer_plots)
  outputfile <- paste0('../../../writing/2016/journal-manuscript/figures/',
                       name, '.pdf')
  ggsave(outputfile, answer_plots, 
         width = 6, height = 6, bg = "transparent")
}
#generateAnswererPredictiveFit('answerer_PragOnlyPredictives', 'withTypicality')
generateAnswererPredictiveFit('answerer_PragOnlyPredictives', 'withoutTypicality')
```