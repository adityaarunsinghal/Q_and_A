var uniformDraw = function (xs) {
  return xs[randomInteger(xs.length)];
};

var mean = function(thunk){
  return expectation(Infer({method: 'enumerate'}, thunk), function(v){return v;});
};

var negate = function(predicate){
  return function(x){
    return !predicate(x);
  };
};

var identity = function(x){
 return x;
};

var condition = function(x){
 factor(x ? 0 : -Infinity);
};

var foreach = function(lst, fn) {
  var foreach_ = function(i) {
    if (i < lst.length) {
      fn(lst[i]);
      foreach_(i + 1);
    }
  };
  foreach_(0);
};

// For some reason, this breaks when you put it in the header...
// var savePredictive = function (questionerERP, qud, item){
//   foreach(questionerERP.support([]),function(s){
//     var strippedQuestion = qa.butLast(s).split("Is")[1].toLowerCase();
//     query.add([qud, item[0], item[1], strippedQuestion],
// 	      Math.exp(questionerERP.score(s)));
//   });
// };

// var getPredictive = function() {
//  return query.table;
//};


var questionToNode = cache(function(utterance){
  var temp = qa.butLast(utterance).split("Is");
  var node = temp[1].toLowerCase();
  return node;
});

var locationAssignments = qa.permute([1,2,3,4]);

var taxonomyAnswerMeaning = cache(function(utterance){
  var temp = utterance.split("@");
  var node = temp[0];
  var location = qa.butLast(temp[1]);
  return function(world){
    return world[node] == location; 
  };
});

var isTaxonomyAnswer = cache(function(qudSpace, x){
  return ((last(x) === '.') &
	  (_.contains(qudSpace, qa.butLast(x).split("@")[0])));
});

var meaning = cache(function(qudSpace, utterance){
  return (isTaxonomyAnswer(qudSpace, utterance) ? taxonomyAnswerMeaning(utterance) :
          utterance === 'null' ? function(w){return true;} :
          undefined);
});

// our model has two parameters: rationality controls how strongly
// optimizing an agent is; beta controls to what extent participants draw from an
// empirical prior (1) vs. a uniform prior (0) on saliency. 
var QAmodel = function(type, domain, rationality,  beta) {
  var knowledge = qa.buildKnowledge(type, domain);
  var unifTaxonomy = knowledge.unifTaxonomy;
  var empTaxonomy = knowledge.empTaxonomy;
  var qudSpace = knowledge.qudSpace;
  var labelSpace = knowledge.labelSpace;

  // Takes a taxonomy object with saliency probabilities
  // and picks one item from each label to be 'the salient one'
  var sampleSalienceAssignment = function() {
    var tax = flip(beta) ? empTaxonomy : unifTaxonomy;
    return mapObject(function(label, probObj) {
      var vals = _.values(probObj);
      var salientItem = categorical(vals, _.keys(probObj));
      return salientItem;
    }, tax);
  };
  
  var worldPrior = function() {
    var locAssignment = uniformDraw(locationAssignments);
    return _.object(qudSpace, locAssignment);
  };

  var questionPrior = function() {
    var v = uniformDraw(labelSpace);
    return 'whereIs' + v.charAt(0).toUpperCase() + v.slice(1) + '?';
  };

  var questionSpace = Infer({method: 'enumerate'}, function(){
    return questionPrior();
  }).support();

  var answerPrior = function(world){
    var loc = uniformDraw([1,2,3,4]);
    var leaf = uniformDraw(_.keys(world));
    return leaf + '@' + loc + ".";
  };
  
  // returns a function that maps world to the gate we should pick to find
  // a leaf under the given node
  var makeQUD = function(node, tax) {
    return function(world){
      var salientObj = tax ? tax[node] : node;
      return world[salientObj];
    };
  };
  
  var nameToQUD = function(qudName){
    if(_.contains(questionSpace, qudName)) {
      var salienceGuess = sampleSalienceAssignment();
      return makeQUD(questionToNode(qudName), salienceGuess);
    } else if (_.contains(qudSpace, qudName)) {
      return makeQUD(qudName);
    } else {
      return console.error('unknown qud name', qudName);
    }
  };

  var qudPrior = function() {
    return uniformDraw(qudSpace);
  };

  var constructProjectedWorldPrior = cache(function(qud_node) {
    var qud = nameToQUD(qud_node);
    return Infer({method: 'enumerate'}, function(){
      return qud(worldPrior());
    });
  });
 
  var interpreter = cache(function(answer){
    return Infer({method: 'enumerate'}, function(){
      var world = worldPrior();
      var answerMeaning = meaning(qudSpace, answer);
      condition(answerMeaning(world));
      return world;
    });
  });
  
  var makeTruthfulAnswerPrior = cache(function(trueWorld) {
    var truthfulAnswerPrior = Infer({method: 'enumerate'}, function(){
      var answer = answerPrior(trueWorld);
      factor(interpreter(answer).score(trueWorld));
      return answer;
    });
    return truthfulAnswerPrior;
  });

  var literalAnswerer = cache(function(question, trueWorld) {
    return Infer({method: 'enumerate'}, function(){
      var answer = answerPrior(trueWorld);
      factor(interpreter(answer).score(trueWorld) * rationality);
      return answer;
    });
  });
  
  var literalQuestioner = cache(function(qud_node) {
    var qud = nameToQUD(qud_node);
    var projectedWorldPrior = constructProjectedWorldPrior(qud_node);
    return Infer({method: 'enumerate'}, function(){
      var question = questionPrior();
      var expectedKL = mean(function(){
        var trueWorld = worldPrior();
        var answer = sample(literalAnswerer(question, trueWorld));
        var projectedWorldPosterior = Infer({method: 'enumerate'}, function(){
          var world = sample(interpreter(answer));
          return qud(world);
        });
        return qa.KL(projectedWorldPosterior, projectedWorldPrior);
      });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var explicitAnswerer = cache(function(question, trueWorld) {
    var truthfulAnswerPrior = makeTruthfulAnswerPrior(trueWorld);
    return Infer({method: 'enumerate'}, function(){
      // Remember this is stochastic for a question...
      var qud = nameToQUD(question);
      var answer = sample(truthfulAnswerPrior);
      var score = mean(function(){
	var inferredWorld = sample(interpreter(answer));
	return (qud(trueWorld) == qud(inferredWorld) ? 1 : 0);
      });
      factor(Math.log(score) * rationality);
      return answer;
    });
  });

  var explicitQuestioner = cache(function(qudName) {
    var qud = nameToQUD(qudName);
    var projectedWorldPrior = constructProjectedWorldPrior(qudName);
    return Infer({method: 'enumerate'}, function(){
      var question = questionPrior();
      var expectedKL = mean(function(){
	var trueWorld = worldPrior();
	var answer = sample(explicitAnswerer(question, trueWorld));
	var projectedWorldPosterior = Infer({method: 'enumerate'}, function(){
	  var world = sample(interpreter(answer));
	  return qud(world);
	});
	return qa.KL(projectedWorldPosterior, projectedWorldPrior);
      });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var pragmaticAnswerer = cache(function(question, trueWorld){
    var qudPosterior = Infer({method: 'enumerate'}, function(){
      var qudName = qudPrior();
      var qud = nameToQUD(qudName);
      var q_erp = explicitQuestioner(qudName);
      factor(q_erp.score(question));
      return qudName;
    });
    var truthfulAnswerPrior = makeTruthfulAnswerPrior(trueWorld);
    return Infer({method: 'enumerate'}, function(){
      var qud = nameToQUD(sample(qudPosterior));
      var answer = sample(truthfulAnswerPrior);
      var score = mean(function(){
	var inferredWorld = sample(interpreter(answer));
	return (qud(trueWorld) == qud(inferredWorld)) ? 1.0 : 0.0;
      });
      factor(Math.log(score) * rationality);
      return answer;
    });
  });

  var pragmaticQuestioner = cache(function(qudName) {
    var qud = nameToQUD(qudName);
    var projectedWorldPrior = constructProjectedWorldPrior(qudName);
    return Infer({method: 'enumerate'}, function(){
      var question = questionPrior();
      var expectedKL = mean(function(){
        var trueWorld = worldPrior();
        var answer = sample(pragmaticAnswerer(question, trueWorld));
        var projectedWorldPosterior = Infer({method: 'enumerate'}, function(){
          var world = sample(interpreter(answer));
          return qud(world);
        });
        return qa.KL(projectedWorldPosterior, projectedWorldPrior);
      });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var runTFBTQuestioner = cache(function(qudName, coinFlip) {
    var qud = nameToQUD(qudName);
    var projectedWorldPrior = constructProjectedWorldPrior(qudName);
    return Infer({method: 'enumerate'}, function(){
      var question = questionPrior();
      var expectedKL = mean(function(){
        var trueWorld = worldPrior();
        var answer = (coinFlip ?
		      sample(pragmaticAnswerer(question, trueWorld)) :
		      sample(explicitAnswerer(question, trueWorld)));
        var projectedWorldPosterior = Infer({method: 'enumerate'}, function(){
          var world = sample(interpreter(answer));
          return qud(world);
        });
        return qa.KL(projectedWorldPosterior, projectedWorldPrior);
      });
      factor(expectedKL * rationality);
      return question;
    });    
  });
  
  var runAnswererModel = function(answererModel, question) {
    return Infer({method: 'enumerate'}, function() {
      var trueWorld = worldPrior();
      var ansERP = answererModel(question, trueWorld);
      var ans = sample(ansERP);
      return ans.split("@")[0] + ".";
    });
  };
  
  return {qudSpace : qudSpace,
          questionSpace : questionSpace,
          pragQ : pragmaticQuestioner,
          litQ : literalQuestioner,
          expQ: explicitQuestioner,
          pragA : pragmaticAnswerer,
          litA : literalAnswerer,
          expA: explicitAnswerer,
	  runAnswererModel: runAnswererModel,
	  runTFBTQuestioner: runTFBTQuestioner
	 };
};
