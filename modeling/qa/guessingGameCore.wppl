var uniformDraw = function (xs) {
  return xs[randomInteger(xs.length)];
};

var mean = function(thunk){
  return expectation(Enumerate(thunk), function(v){return v;});
};

var negate = function(predicate){
  return function(x){
    return !predicate(x);
  };
};

var identity = function(x){
 return x;
};

var condition = function(x){
 factor(x ? 0 : -Infinity);
};

var QAmodel = function(conditionObj) {
  var taxonomy = conditionObj.taxonomy;
  var qudSpace = conditionObj.qudSpace;
  var labelSpace = conditionObj.labelSpace;
  var exampleWorld = conditionObj.exampleWorld;

  // set up world space: All possible assignments of four objects to four positions
  var worldSpace = map(function(perm) {
    return _.object(qa.leaves(taxonomy), perm);
  }, qa.permute([1,2,3,4]));

  var questionSpace = map(function(v){
    return 'whereIs' + v.charAt(0).toUpperCase() + v.slice(1) + '?';
  }, labelSpace);

  // Can tell questioner about a location of one object
  var fullAnswerSpace = qa.flatten(map(function(leaf){
    map(function(loc){
      return leaf + '@' + loc + ".";
    }, [1,2,3,4]);
  }, qa.leaves(taxonomy)));

  var worldPrior = function() {
    return uniformDraw(worldSpace);
  };

  // returns a function that maps world to the gate we should pick to find
  // a leaf under the given node
  var makeQUD = function(node){
    var subtree = qa.findSubtree(node, taxonomy);
    var leavesBelowNode = subtree === null ? [node] : qa.leaves(subtree);
    return function(world){
      return map(function(node) {return world[node];}, leavesBelowNode);
    };
  };

  // These are the objects the questioner might be interested in
  var qudNodePrior = function() {
    return uniformDraw(qudSpace);
  };

  var questionPrior = function() {
    return uniformDraw(questionSpace);
  };

  var questionToNode = function(utterance){
    var temp = qa.butLast(utterance).split("Is");
    var node = temp[1].toLowerCase();
    return node;
  };

  var fullAnswerPrior = function(){
    return uniformDraw(fullAnswerSpace);
  };

  var isTaxonomyQuestion = function(x){
    var testableX = (last(x) === '?') ? x.split("Is")[1].toLowerCase() : x;
    return (last(testableX) === '?') & (qa.isNodeInTree(qa.butLast(testableX), taxonomy));
  };

  var taxonomyQuestionMeaning = cache(function(utterance){
    var node = questionToNode(utterance);
    var subtree = qa.findSubtree(node, taxonomy);
    var leavesBelowNode = subtree === null ? [node] : qa.leaves(subtree);
    return function(world){
      return map(function(node) {return world[node];}, leavesBelowNode);
    };
  });

  var isTaxonomyAnswer = cache(function(x){
    return (last(x) === '.') & (qa.isNodeInTree(qa.butLast(x).split("@")[0], taxonomy));
  });

  var taxonomyAnswerMeaning = cache(function(utterance){
    var temp = utterance.split("@");
    var node = temp[0];
    var location = qa.butLast(temp[1]);
    return function(x){
      return x[node] == location; // return true if the object really is in location
    };
  });

  var meaning = cache(function(utterance){
    return (isTaxonomyQuestion(utterance) ? taxonomyQuestionMeaning(utterance) :
            isTaxonomyAnswer(utterance) ? taxonomyAnswerMeaning(utterance) :
            utterance === 'null' ? function(w){return true;} :
            undefined);
  });

  var getFitnessVals = function(labelVal) {
    var labeledSubtree = qa.findSubtree(labelVal, taxonomy);
    return map(function(objectVal) {
      // match if object is a decendent of the labelVal 
      // have to hack it a bit if the label is a leaf of the tree
      var match = (labeledSubtree == null  
                   ? objectVal == labelVal 
                   : qa.isNodeInTree(objectVal, labeledSubtree));
      // will eventually want to sample instead of fixing at 0...
      return match ? 0 : -Infinity;
    }, qudSpace);
  };

  var fitnessMat = function() {
    reduce(function(labelVal, memo) {
      var innerDict = _.object(qudSpace, getFitnessVals(labelVal));
      return _.extend(memo, _.object([[labelVal,innerDict]]));
    }, {}, labelSpace);
  };

  // For "x@n."-style answers, the question doesn't play any role.
  var interpreter = cache(function(answer){
    return Enumerate(function(){
      var world = worldPrior();
      var answerMeaning = meaning(answer);
      condition(answerMeaning(world));
      return world;
    });
  });

  var literalAnswerer = cache(function(question, trueWorld, rationality) {
    // Pick answer conditioned on communicating question predicate value
    return Enumerate(function(){
      var answer = fullAnswerPrior();
      factor(interpreter(answer).score([], trueWorld) * rationality);
      return answer;
    });
  });

  var literalQuestioner = cache(function(qud_node, rationality) {
    var qud = (makeQUD(qud_node));
    Enumerate(function(){
      var question = questionPrior();
      var prior = Enumerate(function(){return qud(worldPrior());});
      var expectedKL = mean(function(){
        var trueWorld = worldPrior();
        var answer = sample(literalAnswerer(question, trueWorld, rationality));
        var posterior = Enumerate(function(){
          var world = sample(interpreter(answer));
          return qud(world);
        });
        return qa.KL(posterior, prior);
      });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var explicitAnswerer = cache(function(question, trueWorld, rationality) {
    var qud = makeQUD(questionToNode(question));
    return Enumerate(function(){
      var truthfulAnswerPrior = Enumerate(function(){
        var answer = fullAnswerPrior();
        factor(interpreter(answer).score([], trueWorld));
        return answer;
      });
      var answer = sample(truthfulAnswerPrior);
      var score = mean(function(){
        var inferredWorld = sample(interpreter(answer));
        var inferredLocs = qud(inferredWorld);
        var trueLocs = qud(trueWorld);
//        var posToCheck = randomInteger(inferredLocs.length);
        return (_.isEqual(trueLocs, inferredLocs) ? 1 : 0);
      });
      factor(Math.log(score) * rationality);
      return answer;
    });
  });
  
  
  var explicitQuestioner = cache(function(qud_node, rationality) {
    var qud = makeQUD(qud_node);
    return Enumerate(function(){
      var question = questionPrior();
      // What is the gate value I'd guess under my prior?
      var prior = Enumerate(function(){
        return qud(worldPrior());
      });
      var expectedKL = mean(
        function(){
          // What do I expect the world to be like?
          var trueWorld = worldPrior();
          // If I ask this question, what answer do I expect to get,
          // given what the world is like?
          var answer = sample(explicitAnswerer(question, trueWorld, rationality));
          var posterior = Enumerate(function(){
            // Given this answer, how would I update my distribution on worlds?
            var world = sample(interpreter(answer));
            // What is the value of the predicate I care about under
            // this new distribution on worlds?
            return qud(world);
          });
          return qa.KL(posterior, prior);
        });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var pragmaticAnswerer = cache(function(question, trueWorld, rationality){
    var qudNodePosterior = Enumerate(function(){
      var qudNode = qudNodePrior();
      var q_erp = explicitQuestioner(qudNode, rationality);
      factor(q_erp.score([], question) * 4); // This is arbitrarily set -- 1 doesn't give full range of predictions
      return qudNode;
    });
    return Enumerate(function(){
      var qud = makeQUD(sample(qudNodePosterior));
      // Pick answer conditioned on communicating question predicate value

      var truthfulAnswerPrior = Enumerate(function(){
        var answer = fullAnswerPrior();
        factor(interpreter(answer).score([], trueWorld));
        return answer
      })
      var answer = sample(truthfulAnswerPrior);
      var score = mean(function(){
        var inferredWorld = sample(interpreter(answer));
        var inferredLocs = qud(inferredWorld);
        var trueLocs = qud(trueWorld);
        var posToCheck = randomInteger(inferredLocs.length); // always 1, here
        return (_.isEqual(trueLocs[posToCheck], inferredLocs[posToCheck]) ? 1 : 0);
      });
      factor(Math.log(score) * rationality);
      return answer;
    });
  })

  var pragmaticQuestioner = cache(function(qud_node, rationality) {
    var qud = (makeQUD(qud_node))
    Enumerate(function(){
      var question = questionPrior();
      // What is the gate value I'd guess under my prior?
      var prior = Enumerate(function(){
        return qud(worldPrior());
      });
      var expectedKL = mean(
        function(){
          // What do I expect the world to be like?
          var trueWorld = worldPrior();
          // If I ask this question, what answer do I expect to get,
          // given what the world is like?
          var answer = sample(pragmaticAnswerer(question, trueWorld, rationality));
          var posterior = Enumerate(function(){
            // Given this answer, how would I update my distribution on worlds?
            var world = sample(interpreter(answer));
            // What is the value of the predicate I care about under
            // this new distribution on worlds?
            return qud(world);
          });
          return qa.KL(posterior, prior);
        });
      factor(expectedKL * rationality);
      return question;
    });
  });
  return {qudSpace : qudSpace,
          questionSpace : questionSpace,
          exampleWorld : exampleWorld,
          pragQ : pragmaticQuestioner,
          litQ : literalQuestioner,
          expQ: explicitQuestioner,
          pragA : pragmaticAnswerer,
          litA : literalAnswerer,
          expA: explicitAnswerer};
};

// World knowledge
var expCondition1 = {
  taxonomy : {
    animal: {
      pet: {
        dog : {
         dalmatian: null,
         poodle: null
       },
       siamese : null
     },
    whale: null // no good category for this thing
    }
  },
  qudSpace : ['dalmatian', 'poodle', 'siamese', 'whale'],
  labelSpace : ['dalmatian', 'dog', 'pet', 'animal'],
  exampleWorld: {dalmatian: 2, poodle: 1, siamese: 3, whale: 4}
};

var expCondition2 = {
  taxonomy : {
    animal: {
      pet: {
        dalmatian: null,
        siamese : null
      },
      cat: {
        lion : null,
        siamese : null
      },
      whale: null // no good category for this thing
    }
  },
  qudSpace : ['dalmatian', 'whale', 'lion', 'siamese'],
  labelSpace : ['pet', 'cat', 'lion', 'animal'],
  exampleWorld: {dalmatian: 2, siamese: 1, lion: 3, whale: 4}

}

var expCondition3 = {
  taxonomy : {
    animal: {
      fish : {
        beta : null,
        goldfish: null,
        angler : null
      },
      pet : {
        dalmatian : null,
        goldfish: null,
        beta : null
      }
    }
  },
  qudSpace : ['beta', 'goldfish', 'angler', 'dalmatian'],
  labelSpace : ['fish', 'pet'],
  exampleWorld: {beta: 1, goldfish: 2, angler: 3, dalmatian: 4}
};
