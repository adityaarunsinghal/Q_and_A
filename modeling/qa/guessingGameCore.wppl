var uniformDraw = function (xs) {
  return xs[randomInteger(xs.length)];
};

var mean = function(thunk){
  return expectation(Enumerate(thunk), function(v){return v;});
};

var negate = function(predicate){
  return function(x){
    return !predicate(x);
  };
};

var identity = function(x){
 return x;
};

var condition = function(x){
 factor(x ? 0 : -Infinity);
};

// our model has two parameters: rationality controls how strongly
// optimizing an agent is; beta controls to what extent participants draw from an
// empirical prior (1) vs. a uniform prior (0) on saliency. 
var QAmodel = function(type, domain, rationality,  beta) {
  var knowledge = qa.buildKnowledge(type, domain);
  var unifTaxonomy = knowledge.unifTaxonomy;
  var empTaxonomy = knowledge.empTaxonomy;
  var qudSpace = knowledge.qudSpace;
  var labelSpace = knowledge.labelSpace;
  var locationAssignments = qa.permute([1,2,3,4]);

  // Takes a taxonomy object with saliency probabilities
  // and picks one item from each label to be 'the salient one'
  var sampleSalienceAssignment = function() {
    var tax = flip(beta) ? unifTaxonomy : empTaxonomy;
    return mapObject(function(label, probObj) {
      var transformedProbs = qa.normalizeArray(map(
	function(v){return Math.pow(v,beta);},
	_.values(probObj)));
      var salientItem = categorical(transformedProbs, _.keys(probObj));
      return salientItem;
    }, tax);
  };
  
  var worldPrior = function() {
    var locAssignment = uniformDraw(locationAssignments);
    return _.object(qudSpace, locAssignment);
  };

  var questionPrior = function() {
    var v = uniformDraw(labelSpace);
    return 'whereIs' + v.charAt(0).toUpperCase() + v.slice(1) + '?';
  };

  var questionSpace = Enumerate(function(){
    return questionPrior();
  }).support();
  
  var questionToNode = function(utterance){
    var temp = qa.butLast(utterance).split("Is");
    var node = temp[1].toLowerCase();
    return node;
  };

  var answerPrior = function(world){
    var loc = uniformDraw([1,2,3,4]);
    var leaf = uniformDraw(_.keys(world));
    return leaf + '@' + loc + ".";
  };

  var isTaxonomyAnswer = function(x){
    return ((last(x) === '.') &
	    (_.contains(qudSpace, qa.butLast(x).split("@")[0])));
  };
  
  var taxonomyAnswerMeaning = function(utterance){
    var temp = utterance.split("@");
    var node = temp[0];
    var location = qa.butLast(temp[1]);
    return function(world){
      return world[node] == location; 
    };
  };

    // returns a function that maps world to the gate we should pick to find
  // a leaf under the given node
  var makeQUD = function(node, tax) {
    return function(world){
      var salientObj = tax ? tax[node] : node;
      return world[salientObj];
    };
  };
  
  var nameToQUD = function(qudName){
    if(_.contains(questionSpace, qudName)) {
      var salienceGuess = sampleSalienceAssignment();
      return makeQUD(questionToNode(qudName), salienceGuess);
    } else if (_.contains(qudSpace, qudName)) {
      return makeQUD(qudName);
    } else {
      return console.error('unknown qud name', qudName);
    }
  };

  var qudPrior = function() {
    return uniformDraw(qudSpace);
  };
  
  var meaning = cache(function(utterance){
    return (isTaxonomyAnswer(utterance) ? taxonomyAnswerMeaning(utterance) :
            utterance === 'null' ? function(w){return true;} :
            undefined);
  });

  var interpreter = cache(function(answer){
    return Enumerate(function(){
      var world = worldPrior();
      var answerMeaning = meaning(answer);
      condition(answerMeaning(world));
      return world;
    });
  });

  var makeTruthfulAnswerPrior = function(trueWorld) {
    var truthfulAnswerPrior = Enumerate(function(){
      var answer = answerPrior(trueWorld);
      factor(interpreter(answer).score([], trueWorld));
      return answer;
    });
    return truthfulAnswerPrior;
  };

  var literalAnswerer = cache(function(question, trueWorld) {
    return Enumerate(function(){
      var answer = answerPrior(trueWorld);
      factor(interpreter(answer).score([], trueWorld) * rationality);
      return answer;
    });
  });

  var literalQuestioner = cache(function(qud_node) {
    var qud = nameToQUD(qud_node);
    return Enumerate(function(){
      var question = questionPrior();
      var prior = Enumerate(function(){return qud(worldPrior());});
      var expectedKL = mean(function(){
        var trueWorld = worldPrior();
        var answer = sample(literalAnswerer(question, trueWorld));
        var posterior = Enumerate(function(){
          var world = sample(interpreter(answer));
          return qud(world);
        });
        return qa.KL(posterior, prior);
      });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var explicitAnswerer = cache(function(question, trueWorld) {
    return Enumerate(function(){
      var qud = nameToQUD(question);
      var truthfulAnswerPrior = makeTruthfulAnswerPrior(trueWorld);
      var answer = sample(truthfulAnswerPrior);
      var score = mean(function(){
	var inferredWorld = sample(interpreter(answer));
	return (qud(trueWorld) == qud(inferredWorld) ? 1 : 0);
      });
      factor(Math.log(score) * rationality);
      return answer;
    });
  });

  var explicitQuestioner = cache(function(qudName) {
    var qud = nameToQUD(qudName);
    return Enumerate(function(){
      var question = questionPrior();
      var prior = Enumerate(function(){
	return qud(worldPrior());});
      var expectedKL = mean(function(){
	var trueWorld = worldPrior();
	var answer = sample(explicitAnswerer(question, trueWorld));
	var posterior = Enumerate(function(){
	  var world = sample(interpreter(answer));
	  return qud(world);
	});
	return qa.KL(posterior, prior);
      });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var pragmaticAnswerer = cache(function(question, trueWorld){
    var qudPosterior = Enumerate(function(){
      var qudName = qudPrior();
      var qud = nameToQUD(qudName);
      var q_erp = explicitQuestioner(qudName);
      factor(q_erp.score([], question));
      return qudName;
    });
    return Enumerate(function(){
      var qud = nameToQUD(sample(qudPosterior));
      var truthfulAnswerPrior = makeTruthfulAnswerPrior(trueWorld);
      var answer = sample(truthfulAnswerPrior);
      var score = mean(function(){
	var inferredWorld = sample(interpreter(answer));
	return (qud(trueWorld) == qud(inferredWorld)) ? 1.0 : 0.0;
      });
      factor(Math.log(score) * rationality);
      return answer;
    });
  });

  var pragmaticQuestioner = cache(function(qudName) {
    var qud = nameToQUD(qudName);
    return Enumerate(function(){
      var question = questionPrior();
      var prior = Enumerate(function(){
        return qud(worldPrior());
      });
      var expectedKL = mean(
        function(){
          var trueWorld = worldPrior();
          var answer = sample(pragmaticAnswerer(question, trueWorld));
          var posterior = Enumerate(function(){
            var world = sample(interpreter(answer));
            return qud(world);
          });
          return qa.KL(posterior, prior);
        });
      factor(expectedKL * rationality);
      return question;
    });
  });

  var runAnswererModel = function(answererModel, question) {
    return Enumerate(function() {
      var trueWorld = worldPrior();
      var ansERP = answererModel(question, trueWorld);
      var ans = sample(ansERP);
      return ans.split("@")[0] + ".";
    });
  };
  
  return {qudSpace : qudSpace,
          questionSpace : questionSpace,
          pragQ : pragmaticQuestioner,
          litQ : literalQuestioner,
          expQ: explicitQuestioner,
          pragA : pragmaticAnswerer,
          litA : literalAnswerer,
          expA: explicitAnswerer,
	  runAnswererModel: runAnswererModel
	 };
};
