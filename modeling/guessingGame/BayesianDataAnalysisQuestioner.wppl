// Run as:
// webppl genQuestionerPredictions.wppl --require ../qa

var data = qa.readCSV("../../MultiExperiment2/data/"
		      + "MultiExp2_BayesianAnalysisInput.csv");
var types = ["branching", "overlapping", "equivocal"];
var domains = ["artifact", "animals", "places", "plants"];
var items = qa.cartesianProductOf([types, domains]);

var modelAnalysis = function() {
  // Sample params
  var alpha = uniform(0,20);
  var beta = uniform(0,1);
  var expVsPrag = flip(0.5);
  
  // Run model and condition on data
  var score = sum(map(function(item) {
    var model = QAmodel(item[0], item[1], alpha, beta);
    var runTFBTQuestioner = model.runTFBTQuestioner;
    return sum(map(function(qud) {
      var itemData = qa.getSubset(data, {type: item[0], domain: item[1], goal: qud});
      var questionerERP = runTFBTQuestioner(qud, expVsPrag);
      var score = sum(map(function(dataRow) {
	return questionerERP.score([], "whereIs" + qa.capitalize(dataRow[3]) + "?");
      }, itemData));
      
      // Store predictions
      foreach(questionerERP.support([]),function(s){
	query.add(["predictive", qud, item[0], item[1], s],
		  Math.exp(questionerERP.score([], s)))
      })
      return score;
    }, model.qudSpace));
  }, items));

  // Store params
  query.add(["parameter", "alpha", "global", "global", "global"], alpha);
  query.add(["parameter", "beta", "global", "global", "global"], beta);
  query.add(["parameter", "expVsPrag", "global", "global", "global"], expVsPrag);

  factor(score);

  return query
};

var outputERP = MCMC(modelAnalysis, {samples: 1000, burn: 0, verbose: true});

console.log('inference complete... printing')

var outfile = "BayesianQuestionerAnalysis.csv"

qa.bayesianErpWriter(outputERP, outfile, ["paramType", "parameter", "item1", 
						 "item2", "value", "prob"])
console.log('output written to ' + outfile)
