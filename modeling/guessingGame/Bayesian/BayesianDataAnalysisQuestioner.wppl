// Run as:
// webppl genQuestionerPredictions.wppl --require ../qa

var data = qa.readCSV("../../../MultiExperiment2/data/"
		      + "MultiExp2_BayesianAnalysisInput.csv");
var types = ["branching", "overlapping", "equivocal"];
var domains = ["artifact", "animals", "places", "plants"];
var items = qa.cartesianProductOf([types, domains]);

var modelAnalysis = function() {
  // Sample params
  var alpha = uniformDraw(_.range(0, 15.01, 1));
  var beta = uniformDraw(_.range(0, 1.01, 0.1));
  var expPragWeight = uniformDraw(_.range(0, 1.01, 0.1));
  var expPragFlip = sample(Bernoulli({p: expPragWeight}));

  globalStore.predictives = {};
  console.log([alpha, beta, expPragWeight, expPragFlip]);

  // Run model and condition on data
  var score = reduce(function(item) {
    var model = QAmodel(item[0], item[1], alpha, beta);
    var runTFBTQuestioner = model.runTFBTQuestioner;
    return reduce(function(qud) {
      var itemData = qa.getSubset(data, {type: item[0], domain: item[1], goal: qud});
      var questionerERP = runTFBTQuestioner(qud, expPragFlip);
      // Save predictives
      foreach(questionerERP.support(),function(s){
	var strippedQuestion = qa.butLast(s).split("Is")[1].toLowerCase();
	var key = [qud, item[0], item[1], strippedQuestion].join(",");
	var newPair = _.object([key], [Math.exp(questionerERP.score(s))]);
	globalStore.predictives = _.extend(globalStore.predictives, newPair);
      });
      return reduce(function(dataRow) {
       	return questionerERP.score("whereIs" + qa.capitalize(dataRow[3]) + "?");
      }, 0, itemData);
    }, 0, model.qudSpace);
  }, 0, items);

  factor(score);
  return {predictive: globalStore.predictives,
	  params : {alpha: alpha, beta: beta,
	  	    expVsPragWeight: expPragWeight,
		    expPragFlip: expPragFlip}};
};

var outputERP = Infer({method: 'enumerate'}, modelAnalysis);

console.log('inference complete... printing');

qa.bayesianErpWriter(outputERP, "data/BayesianQuestionerAnalysis_loose_");

