// Run as:
// webppl BayesianDataAnalysisAnswerer.wppl --require ../qa

var questionToLabel = function(question) {
  return qa.butLast(question).split("Is")[1].toLowerCase();
};

var data = qa.readCSV("../../../MultiExperiment2/data/"
	              + "MultiExp2_BayesianAnalysisInput.csv");

console.log("loaded data");
var types = ["branching", "overlapping", "equivocal"];
var domains = ["artifact", "animals", "places", "plants"];
var items = qa.cartesianProductOf([types, domains]);

var modelAnalysis = function() {
  // Sample params
  var alpha = uniformDraw(_.range(0, 20.01, 0.5));
  var beta = uniformDraw(_.range(0, 1.01, 0.1));
  var expPragWeight = uniformDraw(_.range(0,1.01, 0.1));
  var expPragFlip = sample(Bernoulli({p: expPragWeight}));

  // Run model and condition on data
  var score = sum(map(function(item) {
    var model = QAmodel(item[0], item[1], alpha, beta);
    var runAnswererModel = model.runAnswererModel;
    return sum(map(function(question) {
      var itemData = qa.getSubset(data, {type:item[0], domain: item[1],
  					 question: questionToLabel(question)});
      var answererERP = runAnswererModel(question, expPragFlip);

      // Store predictions
      foreach(answererERP.support(),function(s){
        query.add([questionToLabel(question), item[0], item[1], s],
      		  Math.exp(answererERP.score(s)));
      });

      return sum(map(function(dataRow) {
  	var localScore = answererERP.score(dataRow[5] + ".");
  	return localScore;
      }, itemData));
    }, model.questionSpace));
  }, items));
  
  console.log([alpha,beta,expPragWeight, expPragFlip]);
  console.log(score);
  factor(score);

  return {predictive: query.table, 
	  params : {alpha: alpha, beta: beta,
		    expPragWeight: expPragWeight,
		    expPragFlip: expPragFlip}};
};

var outputERP = Infer({method: 'enumerate'}, modelAnalysis);

// console.log('inference complete... printing');

qa.bayesianErpWriter(outputERP, "data/BayesianAnswererAnalysis_loose_");
