///Fold:
var KL = function(erpTrue, erpApprox){                       
  var values = erpTrue.support([]);                          
  return (sum(map(                                            
    function(value){                                         
      var scoreP = erpTrue.score(value);                     
      var scoreQ = erpApprox.score(value);                   
      var probP = Math.exp(scoreP);                          
      return probP == 0.0 ? 0.0 : probP * (scoreP - scoreQ); 
    }, values)));
};

var foreach = function(lst, fn) {
  var foreach_ = function(i) {
    if (i < lst.length) {
      fn(lst[i]);
      foreach_(i + 1);
    }
  };
  foreach_(0);
};

//   ---------------
// | World knowledge |
//   ---------------

var rows = ['A', 'B', 'C'];
var cols = ['1', '2', '3'];

var bomb = function() {
  return flip() ? 'safe' : 'unsafe';
}

// We exclude worlds where any goal is a priori impossible
// to achieve (this is also important for efficiency...)
var worldPrior = Infer({method: 'enumerate'}, function(){
  var world = {
    'A1' : bomb(), 'A2' : bomb(), 'A3' : bomb(),
    'B1' : bomb(), 'B2' : bomb(), 'B3' : bomb(),
    'C1' : bomb(), 'C2' : bomb(), 'C3' : bomb()
  };
  return world;
});

//  -------------------
// | Question knowledge |
//  -------------------

var questionPrior = Infer({method: 'enumerate'}, function(){
  var row = uniformDraw(rows);
  var col = uniformDraw(cols);  
  return 'is_' + row + col + '_safe?';
});

//  -----------------
// | Answer knowledge |
//  -----------------

var answers = _.flattenDeep(map(function(row) {
  map(function(col) {
    map(function(status) {
      return row + col + '_' + status;
    }, ['safe', 'unsafe']);
  }, cols);
}, rows));

// Allow 1 or 2 pieces of information...
var shortAnswers = map(function(v){return [v]}, answers);
var longAnswers = _.uniq(Infer({method: 'enumerate'}, function() {
  var answer1 = uniformDraw(answers);
  var a1cell = answer1.split('_')[0];
  var answer2 = uniformDraw(_.without(answers, a1cell + '_safe', a1cell + '_unsafe'));
  return sort([answer1, answer2]);
}).support());

var answerPrior = Categorical({vs : shortAnswers.concat(longAnswers)});

var spatialLocationAnswerMeaning = function(utterance){
  return function(world){
    return all(function(v) {
      var components = v.split('_');
      return world[components[0]] === components[1];
    }, utterance);
  };
};

// this cuts out answers that are literally false (mostly for
// computaitonal efficiency reasons)
var makeTruthfulAnswerPrior = dp.cache(function(question, trueWorld, gridState) {
  var cellAskedAbout = question.split("_")[1];
  var validAnswers = filter(function(answer) {
    var isTrue = all(function(v){return trueWorld[v.split('_')[0]] == v.split('_')[1]},
		     answer);
    var responds = any(function(v){return v.split('_')[0] == cellAskedAbout}, answer);
    var alreadyRevealed = any(function(v){
      return (_.includes(gridState['safe'], v.split('_')[0]) ||
	      _.includes(gridState['unsafe'], v.split('_')[0]));
    }, answer);
    return isTrue && responds && !alreadyRevealed;
  }, answerPrior.support());
  var ps = map(function(v) {
    return v.length == 1 ? 2/(1+validAnswers.length) : 1/(1+validAnswers.length);
  }, validAnswers);
  return Categorical({vs: validAnswers, ps : ps});
}, 1000);

//  ------
// | QUDs |
//  ------

var qudPrior = function(){
  var type = flip() ? 'rows' : 'cols';
  return type == 'cols' ? cols : rows;
};

var QUDPosteriorFromMeaning = function(question) {
  if(_.includes(questionPrior.support(), question))
    return Delta({v: [qa.butLast(question).split('_')[1]]});
  else
    console.error('unknown question' + question);
};

var QUDPosteriorFromInference = dp.cache(function(question, gridState){
  return Infer({method: 'enumerate'}, function() {
    var qudName = qudPrior();
    observe(questioner('explicit', qudName, gridState), question);
    return qudName;
  });
}, 1000);

//  -------
// | Models |
//  -------

var spatialLocationQUD = function(qudName) {
  return function(world){
    return (_.includes(cols, qudName) ? qa.completeCol(qudName, world) :
	    _.includes(rows, qudName) ? qa.completeRow(qudName, world) :
	    qa.cellMatch(qudName, world));
  };
};

var spatialNameToQUD = function(qudName){
  if(qudName == 'identity') 
    return function(w) {return w;};
  else if(qudName.length > 1) {
    return function(w) {map(function(qud) { return spatialLocationQUD(qud)(w);}, qudName)};
  } else {
    return spatialLocationQUD(qudName);
  }
};

var getPriorProb = dp.cache(function(goal, gridState) {
  var consistentWorldPrior = makeConsistentWorldPrior(gridState);
  var qud = spatialNameToQUD(goal);                                              
  return Infer({method: 'enumerate'}, function() {
    var world = sample(consistentWorldPrior);
    return qud(world);
  });
}, 10000);

// Note that in principle we should be conditioning on hearing back from
// answerer here, but in this case, they are equivalent
// var A = answerer(type, question, world, gridState);
var getPosteriorProb = dp.cache(function(type, question, answer, goal, gridState) {
  var consistentWorldPrior = makeConsistentWorldPrior(gridState);
  var qud = spatialNameToQUD(goal);
  return Infer({method: 'enumerate'}, function(){
    var world = sample(consistentWorldPrior);
    var A = answerer(type, question, world, gridState);
    observe(A, answer);
    return qud(world);
  });
}, 10000);

var Qrationality = 1000;
var Arationality = 10;

// This takes subset of worlds where the 'known' revealed cells
// are true (i.e. when people start with a map, or after revealing more)
var makeConsistentWorldPrior = dp.cache(function(gridState) {
  return Categorical({vs : filter(function(w) {
    return (all(function(v) {return w[v] == 'safe';}, gridState['safe']) &&
	    all(function(v) {return w[v] == 'unsafe';}, gridState['unsafe']));
  }, worldPrior.support())});
}, 10000);

var makeValidQuestionPrior = dp.cache(function(gridState) {
  return Categorical({vs: filter(function(q) {
    return (!_.includes(gridState['safe'], q.split('_')[1]) &&
	    !_.includes(gridState['unsafe'], q.split('_')[1]));
  }, questionPrior.support())});
});

var questioner = dp.cache(function(type, goal, gridState) {
  var consistentWorldPrior = makeConsistentWorldPrior(gridState);
  var validQuestionPrior = makeValidQuestionPrior(gridState);
  return Infer({method: 'enumerate'}, function() {
    var question = sample(validQuestionPrior);
    var trueGoal = goal;    
    var utility = expectation(consistentWorldPrior, function(trueWorld) {
      var possibleAnswer = answerer(type, question, trueWorld, gridState);
      var exp =  expectation(possibleAnswer, function(answer){
	var priorProb = getPriorProb(trueGoal, gridState);
	var posteriorProb = getPosteriorProb(type, question, answer, trueGoal, gridState);
	return KL(posteriorProb, priorProb);
      });
      return exp;
    });
    factor(utility.toFixed(8) * Qrationality);
    return question;
  });
}, 10000);

var interpreter = dp.cache(function(answer, gridState){
  var consistentWorldPrior = makeConsistentWorldPrior(gridState);
  return Infer({method: 'enumerate'}, function(){
    var world = sample(consistentWorldPrior);
    var answerMeaning = spatialLocationAnswerMeaning(answer);
    condition(answerMeaning(world));
    return world;
  });
}, 10000);
  
var answerer = dp.cache(function(type, question, trueWorld, gridState) {
  var truthfulAnswerPrior = makeTruthfulAnswerPrior(question, trueWorld, gridState);
  var qudPosterior = (
    type === 'pragmatic' ? QUDPosteriorFromInference(question, gridState) :
      type === 'explicit' ? QUDPosteriorFromMeaning(question) :
      type === 'literal' ? Delta({v: 'identity'}) :
      console.error('type not recognized')
  );
  if(type == 'explicit') {
    return truthfulAnswerPrior;
  } else {
    return Infer({method: 'enumerate'}, function(){
      var qudName = sample(qudPosterior);
      var localQUD = spatialNameToQUD(qudName);
      var answer = sample(truthfulAnswerPrior);
      var possibleWorlds = interpreter(answer, gridState);
      var newUtility = expectation(possibleWorlds, function(w) {
	return _.isEqual(localQUD(w), localQUD(trueWorld));
      });
      factor(Arationality * newUtility );      
      return answer;
    });
  }
}, 10000);

// THIS EXAMPLE ILLUSTRATES WHETHER ANSWERER HAS 'SUFFICIENCY' property (i.e. stops with B3 info instead of TMI)
var example = {
  world: {"A1":"safe","A2":"safe","A3":"safe","B1":"safe","B2":"safe","B3":"safe","C1":"safe","C2":"safe","C3":"safe"},
  initState: {"safe":["B1","B2"],"unsafe":[]}
};

console.log(answerer('pragmatic', 'is_B3_safe?', example.world,example.initState));
console.log(questioner('explicit', ['1', '2', '3'], example.initState));

// IN SOME VERSIONS OF THE MODEL, THE ANSWERER PREFERS REVEALING C1 WHEN ASKED ABOUT B3, which is weird...
// var example = {
//   world: {"A1":"unsafe","A2":"safe","A3":"safe","B1":"safe","B2":"safe","B3":"safe","C1":"unsafe","C2":"safe","C3":"unsafe"},
//   initState: {"safe":["B1","C2"],"unsafe":['C3']}
// };

// console.log(questioner('explicit', ['1', '2', '3'], example.initState));
//console.log(answerer('pragmatic', 'is_B3_safe?', example.world, example.initState));
// console.log(answerer('pragmatic', 'is_A2_safe?', example.world, example.initState));
// console.log(answerer('pragmatic', 'is_C1_safe?', example.world, example.initState));
// console.log(questioner('pragmatic', ['1', '2', '3'], example.initState));


// THIS EXAMPLE IS WHY WE NEED TO USE THE "MAP" QUD (i.e. 'which cols/rows are safe')
// instead of the boolean "ANY" QUD
// var example = {
//   world: {"A1":"safe","A2":"safe","A3":"safe","B1":"safe","B2":"safe","B3":"unsafe","C1":"safe","C2":"unsafe","C3":"safe"},
//   initState: {"safe":["A1","B1","B2","C3"],"unsafe":[]}
// };

// console.log(answerer('pragmatic', 'is_B3_safe?', example.world, example.initState));

// var example = {
//   world: {"A1":"safe","A2":"unsafe","A3":"safe","B1":"safe","B2":"safe","B3":"safe","C1":"safe","C2":"unsafe","C3":"safe"},
//   initState: {"safe":["A1"],"unsafe":[]}
// };
// console.log(answerer('pragmatic', 'is_A2_safe?', example.world, example.initState));
// console.log(questioner('pragmatic', ['A', 'B', 'C'], example.initState));
// console.log(questioner('pragmatic', ['1', '2', '3'], example.initState));

var completeRow = function (grid) {
  return qa.completeRow('A', grid) || qa.completeRow('B', grid) || qa.completeRow('C', grid);
};

var completeCol = function (grid) {
  return qa.completeCol('1', grid) || qa.completeCol('2', grid) || qa.completeCol('3', grid);
};

var colRowExists = function(grid) {
  return completeRow(grid) && completeCol(grid);
}
  
var possibleInitStates = Infer({method: 'enumerate'}, function() {
  var world = sample(worldPrior);
  var safeStates = filter(function(v){return world[v] == 'safe'}, _.keys(world));
  var unsafeStates = filter(function(v){return world[v] == 'unsafe'}, _.keys(world));  
  var initState = {'safe' : uniformDraw(qa.powerset(safeStates)),
		   'unsafe' : uniformDraw(qa.powerset(unsafeStates))};
  condition(colRowExists(world) && (initState['safe'].length + initState['unsafe'].length) < 9);
  return {initState};
});

var writeOutQuestionerPredictions= function() {
  foreach(possibleInitStates.support(), function(item) {
    foreach([['A', 'B', 'C'], ['1', '2', '3']], function(goal) {
      var initState = item.initState;
      var goalString = _.includes(goal, 'A') ? 'rows' : 'columns';
      console.log(initState);
      qa.writeSpatialQuestioner('spatialQuestionerOutputMAP_version.csv',
				['explicit', JSON.stringify(initState), goalString],
				questioner('explicit', goal, initState));
      qa.writeSpatialQuestioner('spatialQuestionerOutputMAP_version.csv',
				['pragmatic', JSON.stringify(initState), goalString],
				questioner('pragmatic', goal, initState));
    });
  });
};

//writeOutQuestionerPredictions();

var possibleAnswererItems = Infer({method: 'enumerate'}, function() {
  var world = sample(worldPrior);
  var safeStates = filter(function(v){return world[v] == 'safe'}, _.keys(world));
  var unsafeStates = filter(function(v){return world[v] == 'unsafe'}, _.keys(world));  
  var initState = {'safe' : uniformDraw(qa.powerset(safeStates)),
		   'unsafe' : uniformDraw(qa.powerset(unsafeStates))};
  condition(colRowExists(world) && (initState['safe'].length + initState['unsafe'].length) < 9);
  return {world, initState};
});

var writeOutAnswererPredictions= function() {
  foreach(possibleAnswererItems.support(), function(item) {
    var initState = item.initState;
    var trueWorld = item.world;
    console.log(item);
    foreach(makeValidQuestionPrior(initState).support(), function(question) {
      qa.writeSpatialAnswerer('spatialAnswererOutput_MAPversion.csv',
      			      ['explicit', question.split('_')[1], JSON.stringify(trueWorld), JSON.stringify(initState)],
      			      answerer('explicit', question, trueWorld, initState));
      qa.writeSpatialAnswerer('spatialAnswererOutput_MAPversion.csv',
      			      ['pragmatic', question.split('_')[1], JSON.stringify(trueWorld), JSON.stringify(initState)],
      			      answerer('pragmatic', question, trueWorld, initState));
      
      });
  });
};

writeOutAnswererPredictions();
