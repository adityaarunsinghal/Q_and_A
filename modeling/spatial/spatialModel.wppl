///fold:
var KL = function(erpTrue, erpApprox){                       
  var values = erpTrue.support([]);                          
  return sum(map(                                            
    function(value){                                         
      var scoreP = erpTrue.score(value);                     
      var scoreQ = erpApprox.score(value);                   
      var probP = Math.exp(scoreP);                          
      return probP == 0.0 ? 0.0 : probP * (scoreP - scoreQ); 
    }, values));                                             
};

//   ---------------
// | World knowledge |
//   ---------------

var rows = ['A', 'B', 'C'];
var cols = ['1', '2', '3'];

var bomb = function() {
  return flip() ? 'safe' : 'unsafe';
}

// We exclude worlds where any goal is a priori impossible
// to achieve (this is also important for efficiency...)
var worldPrior = Infer({method: 'enumerate'}, function(){
  var world = {
    'A1' : bomb(), 'A2' : bomb(), 'A3' : bomb(),
    'B1' : bomb(), 'B2' : bomb(), 'B3' : bomb(),
    'C1' : bomb(), 'C2' : bomb(), 'C3' : bomb()
  };
  // condition(qa.completeCol('1', world) || qa.completeCol('2', world) || qa.completeCol('3', world));
  // condition(qa.completeRow('A', world) || qa.completeRow('B', world) || qa.completeRow('C', world));
 return world;
});

//  -------------------
// | Question knowledge |
//  -------------------

var questionPrior = Infer({method: 'enumerate'}, function(){
  var row = uniformDraw(rows);
  var col = uniformDraw(cols);  
  return 'is_' + row + col + '_safe?';
});

//  -----------------
// | Answer knowledge |
//  -----------------

var answers = _.flattenDeep(map(function(row) {
  map(function(col) {
    map(function(status) {
      return row + col + '_' + status;
    }, ['safe', 'unsafe']);
  }, cols);
}, rows));

// Allow 1 or 2 pieces of information...
var shortAnswers = map(function(v){return [v]}, answers);
var longAnswers = _.uniq(Infer({method: 'enumerate'}, function() {
  var answer1 = uniformDraw(answers);
  var a1cell = answer1.split('_')[0];
  var answer2 = uniformDraw(_.without(answers, a1cell + '_safe', a1cell + '_unsafe'));
  return sort([answer1, answer2]);
}).support());

var answerPrior = Categorical({vs : shortAnswers.concat(longAnswers)});

// this cuts out answers that are literally false (mostly for
// computaitonal efficiency reasons)
var makeTruthfulAnswerPrior = dp.cache(function(question, trueWorld) {
  var cellAskedAbout = question.split("_")[1];
  var validAnswers = filter(function(answer) {
    var isTrue = all(function(v){return trueWorld[v.split('_')[0]] == v.split('_')[1]},
		     answer);
    var responds = any(function(v){return v.split('_')[0] == cellAskedAbout}, answer);
    return isTrue && responds;
  }, answerPrior.support());
  return Categorical({vs: validAnswers});
  // return Infer({method: 'enumerate', model: function(){
  //   var answer = sample(answerPrior);
  //   var score = qa.spatialInterpreterScore(trueWorld, answer, 'identity', worldPrior);
  //   condition(_.isFinite(score));
  //   condition();
  //   return answer;
  // }});
});

//  ------
// | QUDs |
//  ------

var qudPrior = function(){
  var type = flip() ? 'rows' : 'cols';
  return type == 'cols' ? cols : rows// uniformDraw(cols) : uniformDraw(rows);
};

var QUDPosteriorFromMeaning = function(question) {
  if(_.includes(questionPrior.support(), question))
    return Delta({v: [qa.butLast(question).split('_')[1]]});
  else
    console.error('unknown question' + question);
};

var QUDPosteriorFromInference = dp.cache(function(question, gridState){
  return Infer({method: 'enumerate'}, function() {
    var qudName = qudPrior();
    observe(questioner('explicit', qudName, gridState), question);
    return qudName;
  });
});

// Note that because answerer is symmetric across worlds,
// and worlds have equal probability, we can just say
// same or different from true world?

//  -------
// | Models |
//  -------

var spatialLocationQUD = function(qudName) {
  return function(world){
    return (_.includes(cols, qudName) ? qa.completeCol(qudName, world) :
	    _.includes(rows, qudName) ? qa.completeRow(qudName, world) :
	    qa.cellMatch(qudName, world));
  };
};

var spatialNameToQUD = function(qudName){
  if(qudName == 'identity') 
    return function(w) {return w;};
  else 
    return spatialLocationQUD(qudName);
};

var getPriorProb = dp.cache(function(goal) {
  var qud = spatialNameToQUD(goal);                                              
  return Infer({method: 'enumerate'}, function() {
    var world = sample(worldPrior);
    return qud(world);
  });
});

var spatialLocationAnswerMeaning = function(utterance){
  return function(world){
    return all(function(v) {
      var components = v.split('_');
      return world[components[0]] === components[1];
    }, utterance);
  };
};


var getPosteriorProb = dp.cache(function(type, answer, goal) {
  var qud = spatialNameToQUD(goal);
  var meaning = spatialLocationAnswerMeaning(answer);
  return Infer({method: 'enumerate'}, function(){
    var world = sample(worldPrior);
    condition(meaning(world));
    return qud(world);
  });
});


var Qrationality = 100;
var Arationality = 1;

var makeConsistentWorldPrior = dp.cache(function(gridState) {
  return Infer({'method' : 'enumerate'}, function() {
    var world = sample(worldPrior);
    condition(all(function(v) {return world[v] == 'safe'}, gridState));
    return world;
  });
});

var questioner = dp.cache(function(type, goal, gridState) {
  var consistentWorldPrior = makeConsistentWorldPrior(gridState);
  console.log(consistentWorldPrior.support().length);
  return Infer({method: 'enumerate'}, function() {
    var question = sample(questionPrior);
    var trueGoal = uniformDraw(goal);
    console.log('thinking about question ' + question + ' with goal ' + trueGoal);
    
    var utility = expectation(consistentWorldPrior, function(trueWorld) {
      var possibleAnswer = answerer(type, question, trueWorld, gridState);
      var infGain = expectation(possibleAnswer, function(answer){
	var priorProb = getPriorProb(trueGoal);
	var posteriorProb = getPosteriorProb(type, answer, trueGoal);
	return KL(posteriorProb, priorProb);
      });
      return infGain;
    });
    factor(utility * Qrationality);
    return question;
  });
});
				       
var answerer = dp.cache(function(type, question, trueWorld, gridState) {
  var consistentWorldPrior = makeConsistentWorldPrior(gridState);
  var truthfulAnswerPrior = makeTruthfulAnswerPrior(question, trueWorld);
  var qudPosterior = (
    type === 'pragmatic' ? QUDPosteriorFromInference(question, gridState) :
      type === 'explicit' ? QUDPosteriorFromMeaning(question) :
      type === 'literal' ? Delta({v: 'identity'}) :
      console.error('type not recognized')
  );
  if(type == 'pragmatic') {
    console.log('qud posterior for question ' + question);
    console.log(qudPosterior);
  }
  return Infer({method: 'enumerate'}, function(){
    var answer = sample(truthfulAnswerPrior);
    var newUtility = expectation(qudPosterior, function(qudName) {
      var localQUD = uniformDraw(qudName);
      return qa.spatialInterpreterScore(trueWorld, answer, localQUD, consistentWorldPrior);
    });
    factor(newUtility * Arationality);      
    return answer;
  });
});
				       
var trueGoal = qudPrior();
var trueWorld = {'A1' : 'safe', 'A2' : 'safe', 'A3' : 'safe',
		 'B1' : 'safe', 'B2': 'unsafe', 'B3': 'safe',
		 'C1' : 'safe' , 'C2' : 'unsafe', 'C3' : 'safe'};
var consistentWorldPrior = makeConsistentWorldPrior(['A1']);
//makeTruthfulAnswerPrior('is_A1_safe?', trueWorld);
//console.log(answerer('explicit', 'is_A1_safe?', trueWorld, {}));
// console.log(qa.spatialA1Score(answer, 'is_A1_safe?', trueWorld, {answers: truthfulAnswerPrior.support(), worldPrior: worldPrior, rationality: Arationality}));
// console.log(trueWorld);
// console.log(answer);
//questioner('explicit', ['1', '2', '3'], ['A1']);
answerer('pragmatic', 'is_A2_safe?', trueWorld, ['A1']);
//questioner('pragmatic', ['A', 'B'], ['A1'])//goalContext[0]);
